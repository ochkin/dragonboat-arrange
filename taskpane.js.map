{"version":3,"file":"taskpane.js","mappings":"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","sources":["webpack://office-addin-taskpane/./src/backend.ts","webpack://office-addin-taskpane/./src/taskpane/taskpane.ts","webpack://office-addin-taskpane/./src/taskpane/taskpane.html","webpack://office-addin-taskpane/./node_modules/html-loader/dist/runtime/getUrl.js","webpack://office-addin-taskpane/../arranger/fable_modules/fable-library.4.5.0/Reflection.js","webpack://office-addin-taskpane/../arranger/Common.fs.js","webpack://office-addin-taskpane/../arranger/fable_modules/fable-library.4.5.0/Range.js","webpack://office-addin-taskpane/../arranger/search/Backtrack.fs.js","webpack://office-addin-taskpane/../arranger/fable_modules/fable-library.4.5.0/Random.js","webpack://office-addin-taskpane/../arranger/search/Random.fs.js","webpack://office-addin-taskpane/../arranger/fable_modules/fable-library.4.5.0/Array.js","webpack://office-addin-taskpane/../arranger/fable_modules/fable-library.4.5.0/Native.js","webpack://office-addin-taskpane/../arranger/fable_modules/fable-library.4.5.0/Double.js","webpack://office-addin-taskpane/../arranger/fable_modules/fable-library.4.5.0/Global.js","webpack://office-addin-taskpane/../arranger/fable_modules/fable-library.4.5.0/List.js","webpack://office-addin-taskpane/../arranger/fable_modules/fable-library.4.5.0/Option.js","webpack://office-addin-taskpane/../arranger/fable_modules/fable-library.4.5.0/Seq.js","webpack://office-addin-taskpane/../arranger/fable_modules/fable-library.4.5.0/FSharp.Core.js","webpack://office-addin-taskpane/../arranger/fable_modules/fable-library.4.5.0/Date.js","webpack://office-addin-taskpane/../arranger/fable_modules/fable-library.4.5.0/Numeric.js","webpack://office-addin-taskpane/../arranger/fable_modules/fable-library.4.5.0/String.js","webpack://office-addin-taskpane/../arranger/fable_modules/fable-library.4.5.0/Types.js","webpack://office-addin-taskpane/../arranger/fable_modules/fable-library.4.5.0/Util.js","webpack://office-addin-taskpane/webpack/bootstrap","webpack://office-addin-taskpane/webpack/runtime/compat get default export","webpack://office-addin-taskpane/webpack/runtime/define property getters","webpack://office-addin-taskpane/webpack/runtime/global","webpack://office-addin-taskpane/webpack/runtime/hasOwnProperty shorthand","webpack://office-addin-taskpane/webpack/runtime/make namespace object","webpack://office-addin-taskpane/webpack/runtime/publicPath","webpack://office-addin-taskpane/webpack/runtime/jsonp chunk loading","webpack://office-addin-taskpane/webpack/startup"],"sourcesContent":["import { cost, Boat, Paddler } from \"../../arranger/Common.fs.js\";\r\nimport { Some, unwrap } from \"../../arranger/fable_modules/fable-library.4.5.0/Option.js\";\r\nimport { arrangeRandom } from \"../../arranger/search/Random.fs.js\";\r\nimport { searchBacktrack } from \"../../arranger/search/Backtrack.fs.js\";\r\n\r\nconst SIDES = { \"Left\": 1, \"Right\": 2, \"Both\": 3 }\r\n\r\nfunction toPaddlers( rawInput )\r\n{\r\n    let paddlers = [];\r\n    for (let row of rawInput)\r\n    {\r\n        let side = SIDES[ row[2] ]\r\n        let paddler = new Paddler(row[0], Number( row[1] ), side);\r\n        paddlers.push( paddler );\r\n    }\r\n    return paddlers;\r\n}\r\n\r\nfunction toTable( boat )\r\n{\r\n    let result = [];\r\n    for (let i=0; i<max(boat.left.length, boat.right.length); i++)\r\n    {\r\n        let newRow = [\r\n            getName( boat.left[i] ),\r\n            getName( boat.right[i] )\r\n        ];\r\n        result.push( newRow );\r\n    }\r\n    return result;\r\n}\r\n\r\nexport function dummy( input: any[][] )\r\n{\r\n    let result = [ [ \"--left--\", \"--right--\" ] ];\r\n    let row = [];\r\n    for (let paddler of input)\r\n    {\r\n        let name = paddler[ 0 ];\r\n        row.push( name );\r\n        if (2 == row.length)\r\n        {\r\n            result.push( row );\r\n            row = [];\r\n        }\r\n    }\r\n    if (1 == row.length)\r\n    {\r\n        row.push( null );\r\n        result.push( row );\r\n    }\r\n    return result;\r\n}\r\n\r\nfunction getName( opt )\r\n{\r\n    let paddler = unwrap( opt );\r\n    return paddler == null ? null : paddler.Name;\r\n}\r\n\r\nexport function random( input: any[][] )\r\n{\r\n    let paddlers = toPaddlers( input );\r\n\r\n    let boat = arrangeRandom( 20, paddlers);\r\n    \r\n    return toTable( boat );\r\n}\r\n\r\nexport function backtrack( input: any[][] )\r\n{\r\n    let paddlers = toPaddlers( input );\r\n\r\n    let boat = searchBacktrack( 20, paddlers);\r\n    \r\n    return toTable( boat );\r\n}\r\n\r\nfunction max(a: number, b: number) {\r\n    if (a<b)\r\n        return b;\r\n    else\r\n        return a;\r\n}\r\n","/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\r\n * See LICENSE in the project root for license information.\r\n */\r\n\r\nimport { dummy, random, backtrack } from \"../backend\";\r\n\r\n/* global console, document, Excel, Office */\r\n\r\nconst TABLE_NAME = \"Input\";\r\n\r\nOffice.onReady((info) => {\r\n  if (info.host === Office.HostType.Excel) {\r\n    document.getElementById(\"sideload-msg\").style.display = \"none\";\r\n    document.getElementById(\"app-body\").style.display = \"flex\";\r\n    document.getElementById(\"startButton\").onclick = prepare;\r\n    document.getElementById(\"runButton\").onclick = arrange;\r\n  }\r\n});\r\n\r\nexport async function prepare() {\r\n  try {\r\n    await Excel.run(async (context) => {\r\n      /**\r\n       * Insert your Excel code here\r\n       */\r\n      const range = context.workbook.getSelectedRange();\r\n      // const topCell = range.getCell(0, 0)\r\n      // const topRow = range.getRow(0)\r\n      const topThree = range.getAbsoluteResizedRange( 1, 3 );\r\n      // range.load(\"rowIndex,columnIndex\")\r\n      topThree.load(\"address\");\r\n      await context.sync();\r\n      const sheet = range.worksheet;\r\n\r\n      const table = sheet.tables.getItemOrNullObject( TABLE_NAME );\r\n      await context.sync();\r\n\r\n      if (table.isNullObject)\r\n      {\r\n        let expensesTable = sheet.tables.add( topThree.address, true );\r\n        expensesTable.name = TABLE_NAME;\r\n        expensesTable.getHeaderRowRange().values = [[ \"Name\", \"Weight\", \"Side\" ]];\r\n        expensesTable.rows.add(null, [\r\n          [ \"Raymark\", 65, \"Left\" ],\r\n          [ \"Roly\", 63, \"Both\" ],\r\n          [ \"Iya\", 54, \"Right\" ],\r\n          [ \"John\", 67.6, \"Both\" ],\r\n          [ \"Leo\", 59, \"Both\" ],\r\n\r\n          [ \"Doc Pat\", 60, \"Right\" ],\r\n          [ \"LGrace\", 63, \"Left\" ],\r\n          [ \"Joshua\", 85, \"Right\" ],\r\n          [ \"Yormi\", 66, \"Left\" ],\r\n          [ \"Jesus\", 70, \"Both\" ],\r\n\r\n          [ \"Shin\", 50, \"Left\" ],\r\n          [ \"Nanz\", 91.0, \"Right\" ],\r\n          [ \"Sergey\", 84.7, \"Both\" ],\r\n          [ \"Brandon\", 89.1, \"Right\" ],\r\n          [ \"Eugene\", 95, \"Both\" ],\r\n\r\n          [ \"Prashant\", 64, \"Right\" ],\r\n          [ \"Kalesh\", 70, \"Right\" ],\r\n          [ \"Kristoffer\", 74, \"Both\" ],\r\n          [ \"Jenna\", 60, \"Right\" ],\r\n          [ \"Norelee\", 53, \"Left\" ]\r\n        ]);\r\n\r\n        if (Office.context.requirements.isSetSupported(\"ExcelApi\", \"1.2\")) {\r\n          sheet.getUsedRange().format.autofitColumns();\r\n          sheet.getUsedRange().format.autofitRows();\r\n        }\r\n        sheet.activate();\r\n\r\n        // await context.sync();\r\n      }\r\n      else\r\n      {\r\n        console.error(`Table ${TABLE_NAME} already exists!.`);\r\n      }\r\n    });\r\n  } catch (error) {\r\n    console.error(error);\r\n  }\r\n}\r\n\r\n\r\nexport async function arrange()\r\n{\r\n  try\r\n  {\r\n    await Excel.run( async (context) => {\r\n      const sheet = context.workbook.worksheets.getActiveWorksheet();\r\n      const table = sheet.tables.getItemOrNullObject( TABLE_NAME );\r\n      await context.sync();\r\n      if (table.isNullObject)\r\n      {\r\n        console.error( \"Input table not found.\" );\r\n      }\r\n      else\r\n      {\r\n        let input = table.getDataBodyRange().load(\"values,rowCount,columnCount\");\r\n        await context.sync();\r\n        let output = backtrack( input.values )\r\n\r\n        const header = table.getHeaderRowRange().load(\"rowIndex,columnIndex,rowCount,columnCount\");\r\n        await context.sync();\r\n        let target = sheet.getRangeByIndexes(\r\n          header.rowIndex,                 header.columnIndex + header.columnCount + 2,\r\n          output.length + 1, output[0].length\r\n          ).load( \"rowIndex,columnIndex,rowCount,columnCount\" );\r\n        await context.sync();\r\n\r\n        // clean up old data first\r\n        let extendedRange = target.getExtendedRange( Excel.KeyboardDirection.down ).load(\r\n          \"address\");\r\n        extendedRange.clear();\r\n        await context.sync();\r\n\r\n        // now it is ok to write new data\r\n        let lefts = sheet.getRangeByIndexes(\r\n          target.rowIndex + 1, target.columnIndex, target.rowCount, 1\r\n        ).load(\"address\");\r\n        let rights = sheet.getRangeByIndexes(\r\n          target.rowIndex + 1, target.columnIndex + 1, target.rowCount, 1\r\n        ).load(\"address\");\r\n        await context.sync();\r\n        let formattedBoat = [\r\n          [`=SUMPRODUCT(COUNTIF(${lefts.address},${TABLE_NAME}[Name]),${TABLE_NAME}[Weight]) / SUM(${TABLE_NAME}[Weight])`,\r\n           `=SUMPRODUCT(COUNTIF(${rights.address},${TABLE_NAME}[Name]),${TABLE_NAME}[Weight]) / SUM(${TABLE_NAME}[Weight])`],\r\n          ...output.slice(0)\r\n        ];\r\n        target.values = formattedBoat;\r\n\r\n        let summaryHeader = target.getAbsoluteResizedRange(1,2);\r\n        summaryHeader.numberFormat = [ [\"0.0%\"] ];\r\n        await context.sync();\r\n      }\r\n    });\r\n  }\r\n  catch (error) {  console.error(error);  }\r\n}","// Imports\nimport ___HTML_LOADER_GET_SOURCE_FROM_IMPORT___ from \"../../node_modules/html-loader/dist/runtime/getUrl.js\";\nvar ___HTML_LOADER_IMPORT_0___ = new URL(\"./taskpane.css\", import.meta.url);\nvar ___HTML_LOADER_IMPORT_1___ = new URL(\"../../assets/logo-filled.png\", import.meta.url);\n// Module\nvar ___HTML_LOADER_REPLACEMENT_0___ = ___HTML_LOADER_GET_SOURCE_FROM_IMPORT___(___HTML_LOADER_IMPORT_0___);\nvar ___HTML_LOADER_REPLACEMENT_1___ = ___HTML_LOADER_GET_SOURCE_FROM_IMPORT___(___HTML_LOADER_IMPORT_1___);\nvar code = \" <!DOCTYPE html> <html lang=\\\"en-US\\\"> <head> <meta charset=\\\"UTF-8\\\"/> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=Edge\\\"/> <meta name=\\\"viewport\\\" content=\\\"width=device-width,initial-scale=1\\\"> <title>Dragonboat seat arrangement</title> <\" + \"script src=\\\"https://appsforoffice.microsoft.com/lib/1.1/hosted/office.js\\\"><\" + \"/script> <link rel=\\\"stylesheet\\\" href=\\\"https://static2.sharepointonline.com/files/fabric/office-ui-fabric-core/11.0.0/css/fabric.min.css\\\"/> <link href=\\\"\" + ___HTML_LOADER_REPLACEMENT_0___ + \"\\\" rel=\\\"stylesheet\\\"/> </head> <body class=\\\"ms-font-m ms-welcome ms-Fabric\\\"> <header class=\\\"ms-welcome__header ms-bgColor-neutralLighter\\\"> <img width=\\\"90\\\" height=\\\"90\\\" src=\\\"\" + ___HTML_LOADER_REPLACEMENT_1___ + \"\\\" alt=\\\"ochkin\\\" title=\\\"ochkin\\\"/> <h1 class=\\\"ms-font-su\\\">Welcome</h1> </header> <section id=\\\"sideload-msg\\\" class=\\\"ms-welcome__main\\\"> <h2 class=\\\"ms-font-xl\\\">Please <a target=\\\"_blank\\\" href=\\\"https://learn.microsoft.com/office/dev/add-ins/testing/test-debug-office-add-ins#sideload-an-office-add-in-for-testing\\\">sideload</a> your add-in to see app body.</h2> </section> <main id=\\\"app-body\\\" class=\\\"ms-welcome__main\\\" style=\\\"display:none\\\"> <h2 class=\\\"ms-font-xl\\\"> Arrange paddlers in the dragon boat! </h2> <ul class=\\\"ms-List ms-welcome__features\\\"> <li class=\\\"ms-ListItem\\\"> <i class=\\\"ms-Icon ms-Icon--Ribbon ms-font-xl\\\"></i> <span class=\\\"ms-font-m\\\">Click Start to prepare an input table</span> </li> <li class=\\\"ms-ListItem\\\"> <i class=\\\"ms-Icon ms-Icon--Unlock ms-font-xl\\\"></i> <span class=\\\"ms-font-m\\\">Fill in the input table with paddlers' details</span> </li> <li class=\\\"ms-ListItem\\\"> <i class=\\\"ms-Icon ms-Icon--Design ms-font-xl\\\"></i> <span class=\\\"ms-font-m\\\">Click Arrange to get the optimal layout</span> </li> </ul> <p class=\\\"ms-font-l\\\">------------</p> <div role=\\\"button\\\" id=\\\"startButton\\\" class=\\\"ms-welcome__action ms-Button ms-Button--hero ms-font-xl\\\"> <span class=\\\"ms-Button-label\\\">Start</span> </div> <div role=\\\"button\\\" id=\\\"runButton\\\" class=\\\"ms-welcome__action ms-Button ms-Button--hero ms-font-xl\\\"> <span class=\\\"ms-Button-label\\\">Arrange</span> </div> </main> </body> </html> \";\n// Exports\nexport default code;","\"use strict\";\n\nmodule.exports = function (url, options) {\n  if (!options) {\n    // eslint-disable-next-line no-param-reassign\n    options = {};\n  }\n\n  if (!url) {\n    return url;\n  } // eslint-disable-next-line no-underscore-dangle, no-param-reassign\n\n\n  url = String(url.__esModule ? url.default : url);\n\n  if (options.hash) {\n    // eslint-disable-next-line no-param-reassign\n    url += options.hash;\n  }\n\n  if (options.maybeNeedQuotes && /[\\t\\n\\f\\r \"'=<>`]/.test(url)) {\n    return \"\\\"\".concat(url, \"\\\"\");\n  }\n\n  return url;\n};","import { Record, Union } from \"./Types.js\";\nimport { combineHashCodes, equalArraysWith, stringHash } from \"./Util.js\";\nimport Decimal from \"./Decimal.js\";\nexport class CaseInfo {\n    constructor(declaringType, tag, name, fields) {\n        this.declaringType = declaringType;\n        this.tag = tag;\n        this.name = name;\n        this.fields = fields;\n    }\n}\nexport class MethodInfo {\n    constructor(name, parameters, returnType) {\n        this.name = name;\n        this.parameters = parameters;\n        this.returnType = returnType;\n    }\n}\nexport class TypeInfo {\n    constructor(fullname, generics, construct, parent, fields, cases, enumCases) {\n        this.fullname = fullname;\n        this.generics = generics;\n        this.construct = construct;\n        this.parent = parent;\n        this.fields = fields;\n        this.cases = cases;\n        this.enumCases = enumCases;\n    }\n    toString() {\n        return fullName(this);\n    }\n    GetHashCode() {\n        return getHashCode(this);\n    }\n    Equals(other) {\n        return equals(this, other);\n    }\n}\nexport class GenericParameter extends TypeInfo {\n    constructor(name) {\n        super(name);\n    }\n}\nexport function getGenerics(t) {\n    return t.generics != null ? t.generics : [];\n}\nexport function getHashCode(t) {\n    const fullnameHash = stringHash(t.fullname);\n    const genHashes = getGenerics(t).map(getHashCode);\n    return combineHashCodes([fullnameHash, ...genHashes]);\n}\nexport function equals(t1, t2) {\n    if (t1.fullname === \"\") { // Anonymous records\n        return t2.fullname === \"\"\n            && equalArraysWith(getRecordElements(t1), getRecordElements(t2), ([k1, v1], [k2, v2]) => k1 === k2 && equals(v1, v2));\n    }\n    else {\n        return t1.fullname === t2.fullname\n            && equalArraysWith(getGenerics(t1), getGenerics(t2), equals);\n    }\n}\nexport function class_type(fullname, generics, construct, parent) {\n    return new TypeInfo(fullname, generics, construct, parent);\n}\nexport function record_type(fullname, generics, construct, fields) {\n    return new TypeInfo(fullname, generics, construct, undefined, fields);\n}\nexport function anonRecord_type(...fields) {\n    return new TypeInfo(\"\", undefined, undefined, undefined, () => fields);\n}\nexport function union_type(fullname, generics, construct, cases) {\n    const t = new TypeInfo(fullname, generics, construct, undefined, undefined, () => {\n        const caseNames = construct.prototype.cases();\n        return cases().map((fields, i) => new CaseInfo(t, i, caseNames[i], fields));\n    });\n    return t;\n}\nexport function tuple_type(...generics) {\n    return new TypeInfo(\"System.Tuple`\" + generics.length, generics);\n}\nexport function delegate_type(...generics) {\n    return new TypeInfo(\"System.Func`\" + generics.length, generics);\n}\nexport function lambda_type(argType, returnType) {\n    return new TypeInfo(\"Microsoft.FSharp.Core.FSharpFunc`2\", [argType, returnType]);\n}\nexport function option_type(generic) {\n    return new TypeInfo(\"Microsoft.FSharp.Core.FSharpOption`1\", [generic]);\n}\nexport function list_type(generic) {\n    return new TypeInfo(\"Microsoft.FSharp.Collections.FSharpList`1\", [generic]);\n}\nexport function array_type(generic) {\n    return new TypeInfo(\"[]\", [generic]);\n}\nexport function enum_type(fullname, underlyingType, enumCases) {\n    return new TypeInfo(fullname, [underlyingType], undefined, undefined, undefined, undefined, enumCases);\n}\nexport function measure_type(fullname) {\n    return new TypeInfo(fullname);\n}\nexport function generic_type(name) {\n    return new GenericParameter(name);\n}\nexport const obj_type = new TypeInfo(\"System.Object\");\nexport const unit_type = new TypeInfo(\"Microsoft.FSharp.Core.Unit\");\nexport const char_type = new TypeInfo(\"System.Char\");\nexport const string_type = new TypeInfo(\"System.String\");\nexport const bool_type = new TypeInfo(\"System.Boolean\");\nexport const int8_type = new TypeInfo(\"System.SByte\");\nexport const uint8_type = new TypeInfo(\"System.Byte\");\nexport const int16_type = new TypeInfo(\"System.Int16\");\nexport const uint16_type = new TypeInfo(\"System.UInt16\");\nexport const int32_type = new TypeInfo(\"System.Int32\");\nexport const uint32_type = new TypeInfo(\"System.UInt32\");\nexport const int64_type = new TypeInfo(\"System.Int64\");\nexport const uint64_type = new TypeInfo(\"System.UInt64\");\nexport const int128_type = new TypeInfo(\"System.Int128\");\nexport const uint128_type = new TypeInfo(\"System.UInt128\");\nexport const nativeint_type = new TypeInfo(\"System.IntPtr\");\nexport const unativeint_type = new TypeInfo(\"System.UIntPtr\");\nexport const float16_type = new TypeInfo(\"System.Half\");\nexport const float32_type = new TypeInfo(\"System.Single\");\nexport const float64_type = new TypeInfo(\"System.Double\");\nexport const decimal_type = new TypeInfo(\"System.Decimal\");\nexport const bigint_type = new TypeInfo(\"System.Numerics.BigInteger\");\nexport function name(info) {\n    if (Array.isArray(info)) {\n        return info[0];\n    }\n    else if (info instanceof TypeInfo) {\n        const elemType = getElementType(info);\n        if (elemType != null) {\n            return name(elemType) + \"[]\";\n        }\n        else {\n            const i = info.fullname.lastIndexOf(\".\");\n            return i === -1 ? info.fullname : info.fullname.substr(i + 1);\n        }\n    }\n    else {\n        return info.name;\n    }\n}\nexport function fullName(t) {\n    const elemType = getElementType(t);\n    if (elemType != null) {\n        return fullName(elemType) + \"[]\";\n    }\n    else if (t.generics == null || t.generics.length === 0) {\n        return t.fullname;\n    }\n    else {\n        return t.fullname + \"[\" + t.generics.map((x) => fullName(x)).join(\",\") + \"]\";\n    }\n}\nexport function namespace(t) {\n    const elemType = getElementType(t);\n    if (elemType != null) {\n        return namespace(elemType);\n    }\n    else {\n        const i = t.fullname.lastIndexOf(\".\");\n        return i === -1 ? \"\" : t.fullname.substr(0, i);\n    }\n}\nexport function isArray(t) {\n    return getElementType(t) != null;\n}\nexport function getElementType(t) {\n    return t.fullname === \"[]\" && t.generics?.length === 1 ? t.generics[0] : undefined;\n}\nexport function isGenericType(t) {\n    return t.generics != null && t.generics.length > 0;\n}\nexport function isGenericParameter(t) {\n    return t instanceof GenericParameter;\n}\nexport function isEnum(t) {\n    return t.enumCases != null && t.enumCases.length > 0;\n}\nexport function isSubclassOf(t1, t2) {\n    return (t2.fullname === obj_type.fullname) || (t1.parent != null && (t1.parent.Equals(t2) || isSubclassOf(t1.parent, t2)));\n}\nfunction isErasedToNumber(t) {\n    return isEnum(t) || [\n        int8_type.fullname,\n        uint8_type.fullname,\n        int16_type.fullname,\n        uint16_type.fullname,\n        int32_type.fullname,\n        uint32_type.fullname,\n        float16_type.fullname,\n        float32_type.fullname,\n        float64_type.fullname,\n    ].includes(t.fullname);\n}\nfunction isErasedToBigInt(t) {\n    return isEnum(t) || [\n        int64_type.fullname,\n        uint64_type.fullname,\n        int128_type.fullname,\n        uint128_type.fullname,\n        nativeint_type.fullname,\n        unativeint_type.fullname,\n        bigint_type.fullname,\n    ].includes(t.fullname);\n}\nexport function isInstanceOfType(t, o) {\n    if (t.fullname === obj_type.fullname)\n        return true;\n    switch (typeof o) {\n        case \"boolean\":\n            return t.fullname === bool_type.fullname;\n        case \"string\":\n            return t.fullname === string_type.fullname;\n        case \"function\":\n            return isFunction(t);\n        case \"number\":\n            return isErasedToNumber(t);\n        case \"bigint\":\n            return isErasedToBigInt(t);\n        default:\n            return t.construct != null && o instanceof t.construct;\n    }\n}\n/**\n * This doesn't replace types for fields (records) or cases (unions)\n * but it should be enough for type comparison purposes\n */\nexport function getGenericTypeDefinition(t) {\n    return t.generics == null ? t : new TypeInfo(t.fullname, t.generics.map(() => obj_type));\n}\nexport function getEnumUnderlyingType(t) {\n    return t.generics?.[0];\n}\nexport function getEnumValues(t) {\n    if (isEnum(t) && t.enumCases != null) {\n        return t.enumCases.map((kv) => kv[1]);\n    }\n    else {\n        throw new Error(`${t.fullname} is not an enum type`);\n    }\n}\nexport function getEnumNames(t) {\n    if (isEnum(t) && t.enumCases != null) {\n        return t.enumCases.map((kv) => kv[0]);\n    }\n    else {\n        throw new Error(`${t.fullname} is not an enum type`);\n    }\n}\nfunction getEnumCase(t, v) {\n    if (t.enumCases != null) {\n        if (typeof v === \"string\") {\n            for (const kv of t.enumCases) {\n                if (kv[0] === v) {\n                    return kv;\n                }\n            }\n            throw new Error(`'${v}' was not found in ${t.fullname}`);\n        }\n        else {\n            for (const kv of t.enumCases) {\n                if (kv[1] === v) {\n                    return kv;\n                }\n            }\n            // .NET returns the number even if it doesn't match any of the cases\n            return [\"\", v];\n        }\n    }\n    else {\n        throw new Error(`${t.fullname} is not an enum type`);\n    }\n}\nexport function parseEnum(t, str) {\n    // TODO: better int parsing here, parseInt ceils floats: \"4.8\" -> 4\n    const value = parseInt(str, 10);\n    return getEnumCase(t, isNaN(value) ? str : value)[1];\n}\nexport function tryParseEnum(t, str, defValue) {\n    try {\n        defValue.contents = parseEnum(t, str);\n        return true;\n    }\n    catch {\n        return false;\n    }\n}\nexport function getEnumName(t, v) {\n    return getEnumCase(t, v)[0];\n}\nexport function isEnumDefined(t, v) {\n    try {\n        const kv = getEnumCase(t, v);\n        return kv[0] != null && kv[0] !== \"\";\n    }\n    catch {\n        // supress error\n    }\n    return false;\n}\n// FSharpType\nexport function getUnionCases(t) {\n    if (t.cases != null) {\n        return t.cases();\n    }\n    else {\n        throw new Error(`${t.fullname} is not an F# union type`);\n    }\n}\nexport function getRecordElements(t) {\n    if (t.fields != null) {\n        return t.fields();\n    }\n    else {\n        throw new Error(`${t.fullname} is not an F# record type`);\n    }\n}\nexport function getTupleElements(t) {\n    if (isTuple(t) && t.generics != null) {\n        return t.generics;\n    }\n    else {\n        throw new Error(`${t.fullname} is not a tuple type`);\n    }\n}\nexport function getFunctionElements(t) {\n    if (isFunction(t) && t.generics != null) {\n        const gen = t.generics;\n        return [gen[0], gen[1]];\n    }\n    else {\n        throw new Error(`${t.fullname} is not an F# function type`);\n    }\n}\nexport function isUnion(t) {\n    return t instanceof TypeInfo ? t.cases != null : t instanceof Union;\n}\nexport function isRecord(t) {\n    return t instanceof TypeInfo ? t.fields != null : t instanceof Record;\n}\nexport function isTuple(t) {\n    return t.fullname.startsWith(\"System.Tuple\");\n}\n// In .NET this is false for delegates\nexport function isFunction(t) {\n    return t.fullname === \"Microsoft.FSharp.Core.FSharpFunc`2\";\n}\n// FSharpValue\nexport function getUnionFields(v, t) {\n    const cases = getUnionCases(t);\n    const case_ = cases[v.tag];\n    if (case_ == null) {\n        throw new Error(`Cannot find case ${v.name} in union type`);\n    }\n    return [case_, v.fields];\n}\nexport function getUnionCaseFields(uci) {\n    return uci.fields == null ? [] : uci.fields;\n}\n// This is used as replacement of `FSharpValue.GetRecordFields`\n// For `FSharpTypes.GetRecordFields` see `getRecordElements`\n// Object.keys returns keys in the order they were added to the object\nexport function getRecordFields(v) {\n    return Object.keys(v).map((k) => v[k]);\n}\nexport function getRecordField(v, field) {\n    return v[field[0]];\n}\nexport function getTupleFields(v) {\n    return v;\n}\nexport function getTupleField(v, i) {\n    return v[i];\n}\nexport function makeUnion(uci, values) {\n    const expectedLength = (uci.fields || []).length;\n    if (values.length !== expectedLength) {\n        throw new Error(`Expected an array of length ${expectedLength} but got ${values.length}`);\n    }\n    const construct = uci.declaringType.construct;\n    if (construct == null) {\n        return {};\n    }\n    const isSingleCase = uci.declaringType.cases ? uci.declaringType.cases().length == 1 : false;\n    if (isSingleCase) {\n        return new construct(...values);\n    }\n    else {\n        return new construct(uci.tag, values);\n    }\n}\nexport function makeRecord(t, values) {\n    const fields = getRecordElements(t);\n    if (fields.length !== values.length) {\n        throw new Error(`Expected an array of length ${fields.length} but got ${values.length}`);\n    }\n    return t.construct != null\n        ? new t.construct(...values)\n        : fields.reduce((obj, [key, _t], i) => {\n            obj[key] = values[i];\n            return obj;\n        }, {});\n}\nexport function makeTuple(values, _t) {\n    return values;\n}\nexport function makeGenericType(t, generics) {\n    return new TypeInfo(t.fullname, generics, t.construct, t.parent, t.fields, t.cases);\n}\nexport function createInstance(t, consArgs) {\n    // TODO: Check if consArgs length is same as t.construct?\n    // (Arg types can still be different)\n    if (typeof t.construct === \"function\") {\n        return new t.construct(...(consArgs ?? []));\n    }\n    else if (isErasedToNumber(t)) {\n        return 0;\n    }\n    else if (isErasedToBigInt(t)) {\n        return 0n;\n    }\n    else {\n        switch (t.fullname) {\n            case obj_type.fullname:\n                return {};\n            case bool_type.fullname:\n                return false;\n            case decimal_type.fullname:\n                return new Decimal(0);\n            case char_type.fullname:\n                // Even though char is a value type, it's erased to string, and Unchecked.defaultof<char> is null\n                return null;\n            default:\n                throw new Error(`Cannot access constructor of ${t.fullname}`);\n        }\n    }\n}\nexport function getValue(propertyInfo, v) {\n    return v[propertyInfo[0]];\n}\n// Fable.Core.Reflection\nfunction assertUnion(x) {\n    if (!(x instanceof Union)) {\n        throw new Error(`Value is not an F# union type`);\n    }\n}\nexport function getCaseTag(x) {\n    assertUnion(x);\n    return x.tag;\n}\nexport function getCaseName(x) {\n    assertUnion(x);\n    return x.cases()[x.tag];\n}\nexport function getCaseFields(x) {\n    assertUnion(x);\n    return x.fields;\n}\n","import { Record } from \"./fable_modules/fable-library.4.5.0/Types.js\";\r\nimport { array_type, option_type, record_type, enum_type, int32_type, float64_type, string_type } from \"./fable_modules/fable-library.4.5.0/Reflection.js\";\r\nimport { min } from \"./fable_modules/fable-library.4.5.0/Double.js\";\r\nimport { filter, length, initializeInfinite, concat, take, zip, collect, singleton, delay, append, choose, map, max } from \"./fable_modules/fable-library.4.5.0/Seq.js\";\r\nimport { comparePrimitives } from \"./fable_modules/fable-library.4.5.0/Util.js\";\r\nimport { printf, toText, join, replicate } from \"./fable_modules/fable-library.4.5.0/String.js\";\r\nimport { some } from \"./fable_modules/fable-library.4.5.0/Option.js\";\r\nimport { reverse } from \"./fable_modules/fable-library.4.5.0/List.js\";\r\nimport { sumBy } from \"./fable_modules/fable-library.4.5.0/Array.js\";\r\n\r\nexport function canBeLeft(side) {\r\n    if (side === 1) {\r\n        return true;\r\n    }\r\n    else {\r\n        return side === 3;\r\n    }\r\n}\r\n\r\nexport function canBeRight(side) {\r\n    if (side === 2) {\r\n        return true;\r\n    }\r\n    else {\r\n        return side === 3;\r\n    }\r\n}\r\n\r\nexport class Paddler extends Record {\r\n    constructor(Name, Weight, Side) {\r\n        super();\r\n        this.Name = Name;\r\n        this.Weight = Weight;\r\n        this.Side = (Side | 0);\r\n    }\r\n}\r\n\r\nexport function Paddler_$reflection() {\r\n    return record_type(\"arranger.Common.Paddler\", [], Paddler, () => [[\"Name\", string_type], [\"Weight\", float64_type], [\"Side\", enum_type(\"arranger.Common.SIDE\", int32_type, [[\"Left\", 1], [\"Right\", 2], [\"Both\", 3]])]]);\r\n}\r\n\r\nexport class Boat extends Record {\r\n    constructor(size, left, right) {\r\n        super();\r\n        this.size = (size | 0);\r\n        this.left = left;\r\n        this.right = right;\r\n    }\r\n    toString() {\r\n        const this$ = this;\r\n        const maxNameLen = min(46, max(map((paddler) => paddler.Name.length, choose((x) => x, append(this$.left, this$.right))), {\r\n            Compare: comparePrimitives,\r\n        })) | 0;\r\n        const formatPaddler = (paddler_1) => {\r\n            const name = (paddler_1 == null) ? \"\" : paddler_1.Name;\r\n            return name.slice(void 0, (maxNameLen - 1) + 1);\r\n        };\r\n        const horizonalLine = replicate(maxNameLen, \"═\");\r\n        return join(\"\\n\", delay(() => append(singleton(toText(printf(\"╔%s╦%s╗\"))(horizonalLine)(horizonalLine)), delay(() => append(collect((matchValue) => {\r\n            let arg_3, arg_5;\r\n            return singleton((arg_3 = formatPaddler(matchValue[0]), (arg_5 = formatPaddler(matchValue[1]), toText(printf(\"║%*s║%-*s║\"))(maxNameLen)(arg_3)(maxNameLen)(arg_5))));\r\n        }, zip(this$.left, this$.right)), delay(() => singleton(toText(printf(\"╚%s╩%s╝\"))(horizonalLine)(horizonalLine))))))));\r\n    }\r\n}\r\n\r\nexport function Boat_$reflection() {\r\n    return record_type(\"arranger.Common.Boat\", [], Boat, () => [[\"size\", int32_type], [\"left\", array_type(option_type(Paddler_$reflection()))], [\"right\", array_type(option_type(Paddler_$reflection()))]]);\r\n}\r\n\r\nexport function Boat_Make(size, lefts, rights) {\r\n    const makeOneSide = (paddlers) => Array.from(take(size, concat([map(some, reverse(paddlers)), initializeInfinite((_arg) => void 0)])));\r\n    return new Boat(size, makeOneSide(lefts), makeOneSide(rights));\r\n}\r\n\r\nexport function cost(boat) {\r\n    const getWeight = (array) => sumBy((_arg) => {\r\n        if (_arg == null) {\r\n            return 0;\r\n        }\r\n        else {\r\n            return _arg.Weight;\r\n        }\r\n    }, array, {\r\n        GetZero: () => 0,\r\n        Add: (x, y) => (x + y),\r\n    });\r\n    const leftWeight = getWeight(boat.left);\r\n    const rightWeight = getWeight(boat.right);\r\n    const howManyOnWrongSide = (boatSide, isCompatible) => length(filter((arg) => !isCompatible(arg), map((p_1) => p_1.Side, choose((x_1) => x_1, boatSide))));\r\n    return (Math.abs(leftWeight - rightWeight) / (leftWeight + rightWeight)) + ((howManyOnWrongSide(boat.left, canBeLeft) + howManyOnWrongSide(boat.right, canBeRight)) * 1);\r\n}\r\n\r\n","import { compare } from \"./Util.js\";\nimport { unfold, delay } from \"./Seq.js\";\nimport { toUInt64, toInt64, op_Addition, fromZero } from \"./BigInt.js\";\nimport { op_Addition as op_Addition_1, fromParts } from \"./Decimal.js\";\nexport function makeRangeStepFunction(step, stop, zero, add) {\n    const stepComparedWithZero = compare(step, zero) | 0;\n    if (stepComparedWithZero === 0) {\n        throw new Error(\"The step of a range cannot be zero\");\n    }\n    const stepGreaterThanZero = stepComparedWithZero > 0;\n    return (x) => {\n        const comparedWithLast = compare(x, stop) | 0;\n        return ((stepGreaterThanZero && (comparedWithLast <= 0)) ? true : (!stepGreaterThanZero && (comparedWithLast >= 0))) ? [x, add(x, step)] : void 0;\n    };\n}\nexport function integralRangeStep(start, step, stop, zero, add) {\n    const stepFn = makeRangeStepFunction(step, stop, zero, add);\n    return delay(() => unfold(stepFn, start));\n}\nexport function rangeBigInt(start, step, stop) {\n    return integralRangeStep(start, step, stop, fromZero(), op_Addition);\n}\nexport function rangeDecimal(start, step, stop) {\n    return integralRangeStep(start, step, stop, fromParts(0, 0, 0, false, 0), op_Addition_1);\n}\nexport function rangeDouble(start, step, stop) {\n    return integralRangeStep(start, step, stop, 0, (x, y) => (x + y));\n}\nexport function rangeInt64(start, step, stop) {\n    return integralRangeStep(start, step, stop, 0n, (x, y) => toInt64(op_Addition(x, y)));\n}\nexport function rangeUInt64(start, step, stop) {\n    return integralRangeStep(start, step, stop, 0n, (x, y) => toUInt64(op_Addition(x, y)));\n}\nexport function rangeChar(start, stop) {\n    const intStop = stop.charCodeAt(0) | 0;\n    return delay(() => unfold((c) => {\n        if (c <= intStop) {\n            return [String.fromCharCode(c), c + 1];\n        }\n        else {\n            return void 0;\n        }\n    }, start.charCodeAt(0)));\n}\n","import { min } from \"../fable_modules/fable-library.4.5.0/Double.js\";\r\nimport { cons, tail, head, isEmpty, empty as empty_1, length, reverse } from \"../fable_modules/fable-library.4.5.0/List.js\";\r\nimport { empty, map, singleton, append, enumerateWhile, delay, minBy, toList } from \"../fable_modules/fable-library.4.5.0/Seq.js\";\r\nimport { rangeDouble } from \"../fable_modules/fable-library.4.5.0/Range.js\";\r\nimport { Boat_Make, cost } from \"../Common.fs.js\";\r\nimport { comparePrimitives } from \"../fable_modules/fable-library.4.5.0/Util.js\";\r\n\r\nexport function searchBacktrack(size, paddlers) {\r\n    const initialSizeLeft = min(size, paddlers.length) | 0;\r\n    let lefts = reverse(toList(rangeDouble(0, 1, initialSizeLeft - 1)));\r\n    let rights = reverse(toList(rangeDouble(initialSizeLeft, 1, (initialSizeLeft + min(size, paddlers.length - initialSizeLeft)) - 1)));\r\n    return minBy(cost, delay(() => {\r\n        let haveMoreToTraverse = true;\r\n        return enumerateWhile(() => haveMoreToTraverse, delay(() => append((((length(lefts) === size) && (length(rights) === size)) ? true : (((paddlers.length - length(lefts)) - length(rights)) === 0)) ? singleton(Boat_Make(size, toList(delay(() => map((l) => paddlers[l], lefts))), toList(delay(() => map((r) => paddlers[r], rights))))) : empty(), delay(() => {\r\n            let mover = void 0;\r\n            let backup = empty_1();\r\n            return append(enumerateWhile(() => (haveMoreToTraverse && (mover == null)), delay(() => {\r\n                const maxInLeft = !isEmpty(lefts) && (isEmpty(rights) ? true : (head(rights) < head(lefts)));\r\n                if (!isEmpty(rights) && (isEmpty(lefts) ? true : (head(lefts) < head(rights)))) {\r\n                    if (!isEmpty(rights)) {\r\n                        const t = tail(rights);\r\n                        const h = head(rights) | 0;\r\n                        rights = t;\r\n                        backup = cons(h, backup);\r\n                        return empty();\r\n                    }\r\n                    else {\r\n                        throw new Error(\"Match failure\");\r\n                    }\r\n                }\r\n                else if (maxInLeft) {\r\n                    if (!isEmpty(lefts)) {\r\n                        const t_1 = tail(lefts);\r\n                        const h_1 = head(lefts) | 0;\r\n                        lefts = t_1;\r\n                        if (length(rights) < size) {\r\n                            mover = h_1;\r\n                            return empty();\r\n                        }\r\n                        else {\r\n                            backup = cons(h_1, backup);\r\n                            return empty();\r\n                        }\r\n                    }\r\n                    else {\r\n                        throw new Error(\"Match failure\");\r\n                    }\r\n                }\r\n                else {\r\n                    haveMoreToTraverse = false;\r\n                    return empty();\r\n                }\r\n            })), delay(() => {\r\n                const matchValue = mover;\r\n                if (matchValue == null) {\r\n                    return empty();\r\n                }\r\n                else {\r\n                    const number = matchValue | 0;\r\n                    rights = cons(number, rights);\r\n                    return append(enumerateWhile(() => ((length(lefts) < size) && !isEmpty(backup)), delay(() => {\r\n                        if (!isEmpty(backup)) {\r\n                            const t_2 = tail(backup);\r\n                            const h_2 = head(backup) | 0;\r\n                            backup = t_2;\r\n                            lefts = cons(h_2, lefts);\r\n                            return empty();\r\n                        }\r\n                        else {\r\n                            throw new Error(\"Match failure\");\r\n                        }\r\n                    })), delay(() => append(enumerateWhile(() => !isEmpty(backup), delay(() => {\r\n                        if (!isEmpty(backup)) {\r\n                            const t_3 = tail(backup);\r\n                            const h_3 = head(backup) | 0;\r\n                            backup = t_3;\r\n                            rights = cons(h_3, rights);\r\n                            return empty();\r\n                        }\r\n                        else {\r\n                            throw new Error(\"Match failure\");\r\n                        }\r\n                    })), delay(() => {\r\n                        return empty();\r\n                    }))));\r\n                }\r\n            }));\r\n        }))));\r\n    }), {\r\n        Compare: comparePrimitives,\r\n    });\r\n}\r\n\r\n","import { class_type } from \"./Reflection.js\";\nimport { fromFloat64, op_Addition, toInt32, toFloat64, compare, fromInt32, toInt64 } from \"./BigInt.js\";\nimport { fill } from \"./Array.js\";\nfunction Native_random() {\n    return Math.random();\n}\nfunction Native_randomNext(min, max) {\n    if (max < min) {\n        throw new Error(\"minValue must be less than maxValue\");\n    }\n    return Math.floor(Math.random() * (max - min)) + min;\n}\nfunction Native_randomBytes(buffer) {\n    if (buffer == null) {\n        throw new Error(\"Buffer cannot be null\");\n    }\n    for (let i = 0; i < buffer.length; i += 6) {\n        // Pick random 48-bit number. Fill buffer in 2 24-bit chunks to avoid bitwise truncation.\n        let r = Math.floor(Math.random() * 281474976710656); // Low 24 bits = chunk 1.\n        const rhi = Math.floor(r / 16777216); // High 24 bits shifted via division = chunk 2.\n        for (let j = 0; j < 6 && i + j < buffer.length; j++) {\n            if (j === 3) {\n                r = rhi;\n            }\n            buffer[i + j] = r & 255;\n            r >>>= 8;\n        }\n    }\n    ;\n}\nexport class NonSeeded {\n    constructor() {\n    }\n    Next0() {\n        return Native_randomNext(0, 2147483647);\n    }\n    Next1(maxValue) {\n        return Native_randomNext(0, maxValue);\n    }\n    Next2(minValue, maxValue) {\n        return Native_randomNext(minValue, maxValue);\n    }\n    NextDouble() {\n        return Native_random();\n    }\n    NextBytes(buffer) {\n        Native_randomBytes(buffer);\n    }\n}\nexport function NonSeeded_$reflection() {\n    return class_type(\"Random.NonSeeded\", void 0, NonSeeded);\n}\nexport function NonSeeded_$ctor() {\n    return new NonSeeded();\n}\nexport class Seeded {\n    constructor(seed) {\n        this.MBIG = 2147483647;\n        this.inext = 0;\n        this.inextp = 0;\n        this.seedArray = fill(new Array(56), 0, 56, 0);\n        let ii = 0;\n        let mj = 0;\n        let mk = 0;\n        const subtraction = ((seed === -2147483648) ? 2147483647 : Math.abs(seed)) | 0;\n        mj = ((161803398 - subtraction) | 0);\n        this.seedArray[55] = (mj | 0);\n        mk = 1;\n        for (let i = 1; i <= 54; i++) {\n            ii = (((21 * i) % 55) | 0);\n            this.seedArray[ii] = (mk | 0);\n            mk = ((mj - mk) | 0);\n            if (mk < 0) {\n                mk = ((mk + this.MBIG) | 0);\n            }\n            mj = (this.seedArray[ii] | 0);\n        }\n        for (let k = 1; k <= 4; k++) {\n            for (let i_1 = 1; i_1 <= 55; i_1++) {\n                this.seedArray[i_1] = ((this.seedArray[i_1] - this.seedArray[1 + ((i_1 + 30) % 55)]) | 0);\n                if (this.seedArray[i_1] < 0) {\n                    this.seedArray[i_1] = ((this.seedArray[i_1] + this.MBIG) | 0);\n                }\n            }\n        }\n        this.inext = 0;\n        this.inextp = 21;\n    }\n    Next0() {\n        const this$ = this;\n        return Seeded__InternalSample(this$) | 0;\n    }\n    Next1(maxValue) {\n        const this$ = this;\n        if (maxValue < 0) {\n            throw new Error(\"maxValue must be positive\");\n        }\n        return ~~(Seeded__Sample(this$) * maxValue) | 0;\n    }\n    Next2(minValue, maxValue) {\n        const this$ = this;\n        if (minValue > maxValue) {\n            throw new Error(\"minValue must be less than maxValue\");\n        }\n        const range = toInt64(fromInt32(maxValue - minValue));\n        return ((compare(range, toInt64(fromInt32(2147483647))) <= 0) ? (~~(Seeded__Sample(this$) * toFloat64(range)) + minValue) : ~~toInt32(toInt64(op_Addition(toInt64(fromFloat64(Seeded__GetSampleForLargeRange(this$) * toFloat64(range))), toInt64(fromInt32(minValue)))))) | 0;\n    }\n    NextDouble() {\n        const this$ = this;\n        return Seeded__Sample(this$);\n    }\n    NextBytes(buffer) {\n        const this$ = this;\n        if (buffer == null) {\n            throw new Error(\"buffer\");\n        }\n        for (let i = 0; i <= (buffer.length - 1); i++) {\n            buffer[i] = ((Seeded__InternalSample(this$) % (~~255 + 1)) & 0xFF);\n        }\n    }\n}\nexport function Seeded_$reflection() {\n    return class_type(\"Random.Seeded\", void 0, Seeded);\n}\nexport function Seeded_$ctor_Z524259A4(seed) {\n    return new Seeded(seed);\n}\nfunction Seeded__InternalSample(_) {\n    let retVal = 0;\n    let locINext = _.inext;\n    let locINextp = _.inextp;\n    locINext = ((locINext + 1) | 0);\n    if (locINext >= 56) {\n        locINext = 1;\n    }\n    locINextp = ((locINextp + 1) | 0);\n    if (locINextp >= 56) {\n        locINextp = 1;\n    }\n    retVal = ((_.seedArray[locINext] - _.seedArray[locINextp]) | 0);\n    if (retVal === _.MBIG) {\n        retVal = ((retVal - 1) | 0);\n    }\n    if (retVal < 0) {\n        retVal = ((retVal + _.MBIG) | 0);\n    }\n    _.seedArray[locINext] = (retVal | 0);\n    _.inext = (locINext | 0);\n    _.inextp = (locINextp | 0);\n    return retVal | 0;\n}\nexport function Seeded__Sample(this$) {\n    return Seeded__InternalSample(this$) * (1 / this$.MBIG);\n}\nexport function Seeded__GetSampleForLargeRange(this$) {\n    let result = Seeded__InternalSample(this$);\n    if ((Seeded__InternalSample(this$) % 2) === 0) {\n        result = -result;\n    }\n    let d = result;\n    d = (d + (2147483647 - 1));\n    d = (d / (2 * ((2147483647 - 1) >>> 0)));\n    return d;\n}\nexport function nonSeeded() {\n    return NonSeeded_$ctor();\n}\nexport function seeded(seed) {\n    return Seeded_$ctor_Z524259A4(seed);\n}\n","import { cost, Boat_Make, Boat } from \"../Common.fs.js\";\r\nimport { copy, fill, equalsWith } from \"../fable_modules/fable-library.4.5.0/Array.js\";\r\nimport { comparePrimitives, defaultOf, equals } from \"../fable_modules/fable-library.4.5.0/Util.js\";\r\nimport { nonSeeded } from \"../fable_modules/fable-library.4.5.0/Random.js\";\r\nimport { min } from \"../fable_modules/fable-library.4.5.0/Double.js\";\r\nimport { ofArray } from \"../fable_modules/fable-library.4.5.0/List.js\";\r\nimport { initialize, minBy } from \"../fable_modules/fable-library.4.5.0/Seq.js\";\r\n\r\nexport function arrangeRandom(size, paddlers) {\r\n    let testExpr;\r\n    if (size <= 0) {\r\n        return new Boat(0, new Array(0), new Array(0));\r\n    }\r\n    else if ((testExpr = paddlers, !equalsWith(equals, testExpr, defaultOf()) && (testExpr.length === 0))) {\r\n        const size_3 = size | 0;\r\n        return new Boat(size_3, fill(new Array(size_3), 0, size_3, void 0), fill(new Array(size_3), 0, size_3, void 0));\r\n    }\r\n    else {\r\n        const rand = nonSeeded();\r\n        const tempArray = copy(paddlers);\r\n        const a = tempArray;\r\n        let n = a.length;\r\n        while (1 < n) {\r\n            const k = rand.Next1(n) | 0;\r\n            n = ((n - 1) | 0);\r\n            const temp = a[n];\r\n            const value = a[k];\r\n            a[n] = value;\r\n            a[k] = temp;\r\n        }\r\n        const leftSize = min(size, ~~((1 + tempArray.length) / 2)) | 0;\r\n        return Boat_Make(size, ofArray(tempArray.slice(void 0, (leftSize - 1) + 1)), ofArray(tempArray.slice(leftSize, ((leftSize + size) - 1) + 1)));\r\n    }\r\n}\r\n\r\nexport function searchRandom(attempts, size, paddlers) {\r\n    return minBy(cost, initialize(attempts, (_arg) => arrangeRandom(size, paddlers)), {\r\n        Compare: comparePrimitives,\r\n    });\r\n}\r\n\r\n","import { Helpers_allocateArrayFromCons } from \"./Native.js\";\nimport { value as value_2, map as map_1, defaultArg, some } from \"./Option.js\";\nimport { min as min_1, max as max_1 } from \"./Double.js\";\nimport { equals as equals_1, disposeSafe, getEnumerator, copyToArray, defaultOf } from \"./Util.js\";\nimport { SR_indexOutOfBounds } from \"./Global.js\";\nfunction indexNotFound() {\n    throw new Error(\"An index satisfying the predicate was not found in the collection.\");\n}\nfunction differentLengths() {\n    throw new Error(\"Arrays had different lengths\");\n}\nexport function append(array1, array2, cons) {\n    const len1 = array1.length | 0;\n    const len2 = array2.length | 0;\n    const newArray = Helpers_allocateArrayFromCons(cons, len1 + len2);\n    for (let i = 0; i <= (len1 - 1); i++) {\n        newArray[i] = array1[i];\n    }\n    for (let i_1 = 0; i_1 <= (len2 - 1); i_1++) {\n        newArray[i_1 + len1] = array2[i_1];\n    }\n    return newArray;\n}\nexport function filter(predicate, array) {\n    return array.filter(predicate);\n}\nexport function fill(target, targetIndex, count, value) {\n    const start = targetIndex | 0;\n    return target.fill(value, start, (start + count));\n}\nexport function getSubArray(array, start, count) {\n    const start_1 = start | 0;\n    return array.slice(start_1, (start_1 + count));\n}\nexport function last(array) {\n    if (array.length === 0) {\n        throw new Error(\"The input array was empty\\\\nParameter name: array\");\n    }\n    return array[array.length - 1];\n}\nexport function tryLast(array) {\n    if (array.length === 0) {\n        return void 0;\n    }\n    else {\n        return some(array[array.length - 1]);\n    }\n}\nexport function mapIndexed(f, source, cons) {\n    const len = source.length | 0;\n    const target = Helpers_allocateArrayFromCons(cons, len);\n    for (let i = 0; i <= (len - 1); i++) {\n        target[i] = f(i, source[i]);\n    }\n    return target;\n}\nexport function map(f, source, cons) {\n    const len = source.length | 0;\n    const target = Helpers_allocateArrayFromCons(cons, len);\n    for (let i = 0; i <= (len - 1); i++) {\n        target[i] = f(source[i]);\n    }\n    return target;\n}\nexport function mapIndexed2(f, source1, source2, cons) {\n    if (source1.length !== source2.length) {\n        throw new Error(\"Arrays had different lengths\");\n    }\n    const result = Helpers_allocateArrayFromCons(cons, source1.length);\n    for (let i = 0; i <= (source1.length - 1); i++) {\n        result[i] = f(i, source1[i], source2[i]);\n    }\n    return result;\n}\nexport function map2(f, source1, source2, cons) {\n    if (source1.length !== source2.length) {\n        throw new Error(\"Arrays had different lengths\");\n    }\n    const result = Helpers_allocateArrayFromCons(cons, source1.length);\n    for (let i = 0; i <= (source1.length - 1); i++) {\n        result[i] = f(source1[i], source2[i]);\n    }\n    return result;\n}\nexport function mapIndexed3(f, source1, source2, source3, cons) {\n    if ((source1.length !== source2.length) ? true : (source2.length !== source3.length)) {\n        throw new Error(\"Arrays had different lengths\");\n    }\n    const result = Helpers_allocateArrayFromCons(cons, source1.length);\n    for (let i = 0; i <= (source1.length - 1); i++) {\n        result[i] = f(i, source1[i], source2[i], source3[i]);\n    }\n    return result;\n}\nexport function map3(f, source1, source2, source3, cons) {\n    if ((source1.length !== source2.length) ? true : (source2.length !== source3.length)) {\n        throw new Error(\"Arrays had different lengths\");\n    }\n    const result = Helpers_allocateArrayFromCons(cons, source1.length);\n    for (let i = 0; i <= (source1.length - 1); i++) {\n        result[i] = f(source1[i], source2[i], source3[i]);\n    }\n    return result;\n}\nexport function mapFold(mapping, state, array, cons) {\n    const matchValue = array.length | 0;\n    if (matchValue === 0) {\n        return [[], state];\n    }\n    else {\n        let acc = state;\n        const res = Helpers_allocateArrayFromCons(cons, matchValue);\n        for (let i = 0; i <= (array.length - 1); i++) {\n            const patternInput = mapping(acc, array[i]);\n            res[i] = patternInput[0];\n            acc = patternInput[1];\n        }\n        return [res, acc];\n    }\n}\nexport function mapFoldBack(mapping, array, state, cons) {\n    const matchValue = array.length | 0;\n    if (matchValue === 0) {\n        return [[], state];\n    }\n    else {\n        let acc = state;\n        const res = Helpers_allocateArrayFromCons(cons, matchValue);\n        for (let i = array.length - 1; i >= 0; i--) {\n            const patternInput = mapping(array[i], acc);\n            res[i] = patternInput[0];\n            acc = patternInput[1];\n        }\n        return [res, acc];\n    }\n}\nexport function indexed(source) {\n    const len = source.length | 0;\n    const target = new Array(len);\n    for (let i = 0; i <= (len - 1); i++) {\n        target[i] = [i, source[i]];\n    }\n    return target;\n}\nexport function truncate(count, array) {\n    const count_1 = max_1(0, count) | 0;\n    return array.slice(0, (0 + count_1));\n}\nexport function concat(arrays, cons) {\n    const arrays_1 = Array.isArray(arrays) ? arrays : (Array.from(arrays));\n    const matchValue = arrays_1.length | 0;\n    switch (matchValue) {\n        case 0:\n            return Helpers_allocateArrayFromCons(cons, 0);\n        case 1:\n            return arrays_1[0];\n        default: {\n            let totalIdx = 0;\n            let totalLength = 0;\n            for (let idx = 0; idx <= (arrays_1.length - 1); idx++) {\n                const arr_1 = arrays_1[idx];\n                totalLength = ((totalLength + arr_1.length) | 0);\n            }\n            const result = Helpers_allocateArrayFromCons(cons, totalLength);\n            for (let idx_1 = 0; idx_1 <= (arrays_1.length - 1); idx_1++) {\n                const arr_2 = arrays_1[idx_1];\n                for (let j = 0; j <= (arr_2.length - 1); j++) {\n                    result[totalIdx] = arr_2[j];\n                    totalIdx = ((totalIdx + 1) | 0);\n                }\n            }\n            return result;\n        }\n    }\n}\nexport function collect(mapping, array, cons) {\n    return concat(map(mapping, array, defaultOf()), cons);\n}\nexport function where(predicate, array) {\n    return array.filter(predicate);\n}\nexport function indexOf(array, item_1, start, count, eq) {\n    const start_1 = defaultArg(start, 0) | 0;\n    const end$0027 = defaultArg(map_1((c) => (start_1 + c), count), array.length) | 0;\n    const loop = (i_mut) => {\n        loop: while (true) {\n            const i = i_mut;\n            if (i >= end$0027) {\n                return -1;\n            }\n            else if (eq.Equals(item_1, array[i])) {\n                return i | 0;\n            }\n            else {\n                i_mut = (i + 1);\n                continue loop;\n            }\n            break;\n        }\n    };\n    return loop(start_1) | 0;\n}\nexport function contains(value, array, eq) {\n    return indexOf(array, value, void 0, void 0, eq) >= 0;\n}\nexport function empty(cons) {\n    return Helpers_allocateArrayFromCons(cons, 0);\n}\nexport function singleton(value, cons) {\n    const ar = Helpers_allocateArrayFromCons(cons, 1);\n    ar[0] = value;\n    return ar;\n}\nexport function initialize(count, initializer, cons) {\n    if (count < 0) {\n        throw new Error(\"The input must be non-negative\\\\nParameter name: count\");\n    }\n    const result = Helpers_allocateArrayFromCons(cons, count);\n    for (let i = 0; i <= (count - 1); i++) {\n        result[i] = initializer(i);\n    }\n    return result;\n}\nexport function pairwise(array) {\n    if (array.length < 2) {\n        return [];\n    }\n    else {\n        const count = (array.length - 1) | 0;\n        const result = new Array(count);\n        for (let i = 0; i <= (count - 1); i++) {\n            result[i] = [array[i], array[i + 1]];\n        }\n        return result;\n    }\n}\nexport function replicate(count, initial, cons) {\n    if (count < 0) {\n        throw new Error(\"The input must be non-negative\\\\nParameter name: count\");\n    }\n    const result = Helpers_allocateArrayFromCons(cons, count);\n    for (let i = 0; i <= (result.length - 1); i++) {\n        result[i] = initial;\n    }\n    return result;\n}\nexport function copy(array) {\n    return array.slice();\n}\nexport function copyTo(source, sourceIndex, target, targetIndex, count) {\n    copyToArray(source, sourceIndex, target, targetIndex, count);\n}\nexport function reverse(array) {\n    const array_2 = array.slice();\n    return array_2.reverse();\n}\nexport function scan(folder, state, array, cons) {\n    const res = Helpers_allocateArrayFromCons(cons, array.length + 1);\n    res[0] = state;\n    for (let i = 0; i <= (array.length - 1); i++) {\n        res[i + 1] = folder(res[i], array[i]);\n    }\n    return res;\n}\nexport function scanBack(folder, array, state, cons) {\n    const res = Helpers_allocateArrayFromCons(cons, array.length + 1);\n    res[array.length] = state;\n    for (let i = array.length - 1; i >= 0; i--) {\n        res[i] = folder(array[i], res[i + 1]);\n    }\n    return res;\n}\nexport function skip(count, array, cons) {\n    if (count > array.length) {\n        throw new Error(\"count is greater than array length\\\\nParameter name: count\");\n    }\n    if (count === array.length) {\n        return Helpers_allocateArrayFromCons(cons, 0);\n    }\n    else {\n        const count_1 = ((count < 0) ? 0 : count) | 0;\n        return array.slice(count_1);\n    }\n}\nexport function skipWhile(predicate, array, cons) {\n    let count = 0;\n    while ((count < array.length) && predicate(array[count])) {\n        count = ((count + 1) | 0);\n    }\n    if (count === array.length) {\n        return Helpers_allocateArrayFromCons(cons, 0);\n    }\n    else {\n        const count_1 = count | 0;\n        return array.slice(count_1);\n    }\n}\nexport function take(count, array, cons) {\n    if (count < 0) {\n        throw new Error(\"The input must be non-negative\\\\nParameter name: count\");\n    }\n    if (count > array.length) {\n        throw new Error(\"count is greater than array length\\\\nParameter name: count\");\n    }\n    if (count === 0) {\n        return Helpers_allocateArrayFromCons(cons, 0);\n    }\n    else {\n        return array.slice(0, (0 + count));\n    }\n}\nexport function takeWhile(predicate, array, cons) {\n    let count = 0;\n    while ((count < array.length) && predicate(array[count])) {\n        count = ((count + 1) | 0);\n    }\n    if (count === 0) {\n        return Helpers_allocateArrayFromCons(cons, 0);\n    }\n    else {\n        const count_1 = count | 0;\n        return array.slice(0, (0 + count_1));\n    }\n}\nexport function addInPlace(x, array) {\n    array.push(x);\n}\nexport function addRangeInPlace(range, array) {\n    const enumerator = getEnumerator(range);\n    try {\n        while (enumerator[\"System.Collections.IEnumerator.MoveNext\"]()) {\n            addInPlace(enumerator[\"System.Collections.Generic.IEnumerator`1.get_Current\"](), array);\n        }\n    }\n    finally {\n        disposeSafe(enumerator);\n    }\n}\nexport function insertRangeInPlace(index, range, array) {\n    let index_1;\n    let i = index;\n    const enumerator = getEnumerator(range);\n    try {\n        while (enumerator[\"System.Collections.IEnumerator.MoveNext\"]()) {\n            const x = enumerator[\"System.Collections.Generic.IEnumerator`1.get_Current\"]();\n            (index_1 = (i | 0), array.splice(index_1, 0, x));\n            i = ((i + 1) | 0);\n        }\n    }\n    finally {\n        disposeSafe(enumerator);\n    }\n}\nexport function removeInPlace(item_1, array, eq) {\n    const i = indexOf(array, item_1, void 0, void 0, eq) | 0;\n    if (i > -1) {\n        array.splice(i, 1);\n        return true;\n    }\n    else {\n        return false;\n    }\n}\nexport function removeAllInPlace(predicate, array) {\n    const countRemoveAll = (count) => {\n        const i = (array.findIndex(predicate)) | 0;\n        if (i > -1) {\n            array.splice(i, 1);\n            return (countRemoveAll(count) + 1) | 0;\n        }\n        else {\n            return count | 0;\n        }\n    };\n    return countRemoveAll(0) | 0;\n}\nexport function partition(f, source, cons) {\n    const len = source.length | 0;\n    const res1 = Helpers_allocateArrayFromCons(cons, len);\n    const res2 = Helpers_allocateArrayFromCons(cons, len);\n    let iTrue = 0;\n    let iFalse = 0;\n    for (let i = 0; i <= (len - 1); i++) {\n        if (f(source[i])) {\n            res1[iTrue] = source[i];\n            iTrue = ((iTrue + 1) | 0);\n        }\n        else {\n            res2[iFalse] = source[i];\n            iFalse = ((iFalse + 1) | 0);\n        }\n    }\n    return [truncate(iTrue, res1), truncate(iFalse, res2)];\n}\nexport function find(predicate, array) {\n    const matchValue = array.find(predicate);\n    if (matchValue == null) {\n        return indexNotFound();\n    }\n    else {\n        return value_2(matchValue);\n    }\n}\nexport function tryFind(predicate, array) {\n    return array.find(predicate);\n}\nexport function findIndex(predicate, array) {\n    const matchValue = (array.findIndex(predicate)) | 0;\n    if (matchValue > -1) {\n        return matchValue | 0;\n    }\n    else {\n        indexNotFound();\n        return -1;\n    }\n}\nexport function tryFindIndex(predicate, array) {\n    const matchValue = (array.findIndex(predicate)) | 0;\n    if (matchValue > -1) {\n        return matchValue;\n    }\n    else {\n        return void 0;\n    }\n}\nexport function pick(chooser, array) {\n    const loop = (i_mut) => {\n        loop: while (true) {\n            const i = i_mut;\n            if (i >= array.length) {\n                return indexNotFound();\n            }\n            else {\n                const matchValue = chooser(array[i]);\n                if (matchValue != null) {\n                    return value_2(matchValue);\n                }\n                else {\n                    i_mut = (i + 1);\n                    continue loop;\n                }\n            }\n            break;\n        }\n    };\n    return loop(0);\n}\nexport function tryPick(chooser, array) {\n    const loop = (i_mut) => {\n        loop: while (true) {\n            const i = i_mut;\n            if (i >= array.length) {\n                return void 0;\n            }\n            else {\n                const matchValue = chooser(array[i]);\n                if (matchValue == null) {\n                    i_mut = (i + 1);\n                    continue loop;\n                }\n                else {\n                    return matchValue;\n                }\n            }\n            break;\n        }\n    };\n    return loop(0);\n}\nexport function findBack(predicate, array) {\n    const loop = (i_mut) => {\n        loop: while (true) {\n            const i = i_mut;\n            if (i < 0) {\n                return indexNotFound();\n            }\n            else if (predicate(array[i])) {\n                return array[i];\n            }\n            else {\n                i_mut = (i - 1);\n                continue loop;\n            }\n            break;\n        }\n    };\n    return loop(array.length - 1);\n}\nexport function tryFindBack(predicate, array) {\n    const loop = (i_mut) => {\n        loop: while (true) {\n            const i = i_mut;\n            if (i < 0) {\n                return void 0;\n            }\n            else if (predicate(array[i])) {\n                return some(array[i]);\n            }\n            else {\n                i_mut = (i - 1);\n                continue loop;\n            }\n            break;\n        }\n    };\n    return loop(array.length - 1);\n}\nexport function findLastIndex(predicate, array) {\n    const loop = (i_mut) => {\n        loop: while (true) {\n            const i = i_mut;\n            if (i < 0) {\n                return -1;\n            }\n            else if (predicate(array[i])) {\n                return i | 0;\n            }\n            else {\n                i_mut = (i - 1);\n                continue loop;\n            }\n            break;\n        }\n    };\n    return loop(array.length - 1) | 0;\n}\nexport function findIndexBack(predicate, array) {\n    const loop = (i_mut) => {\n        loop: while (true) {\n            const i = i_mut;\n            if (i < 0) {\n                indexNotFound();\n                return -1;\n            }\n            else if (predicate(array[i])) {\n                return i | 0;\n            }\n            else {\n                i_mut = (i - 1);\n                continue loop;\n            }\n            break;\n        }\n    };\n    return loop(array.length - 1) | 0;\n}\nexport function tryFindIndexBack(predicate, array) {\n    const loop = (i_mut) => {\n        loop: while (true) {\n            const i = i_mut;\n            if (i < 0) {\n                return void 0;\n            }\n            else if (predicate(array[i])) {\n                return i;\n            }\n            else {\n                i_mut = (i - 1);\n                continue loop;\n            }\n            break;\n        }\n    };\n    return loop(array.length - 1);\n}\nexport function choose(chooser, array, cons) {\n    const res = [];\n    for (let i = 0; i <= (array.length - 1); i++) {\n        const matchValue = chooser(array[i]);\n        if (matchValue != null) {\n            const y = value_2(matchValue);\n            res.push(y);\n        }\n    }\n    if (equals_1(cons, defaultOf())) {\n        return res;\n    }\n    else {\n        return map((x) => x, res, cons);\n    }\n}\nexport function foldIndexed(folder, state, array) {\n    return array.reduce(((delegateArg, delegateArg_1, delegateArg_2) => folder(delegateArg_2, delegateArg, delegateArg_1)), state);\n}\nexport function fold(folder, state, array) {\n    return array.reduce((folder), state);\n}\nexport function iterate(action, array) {\n    for (let i = 0; i <= (array.length - 1); i++) {\n        action(array[i]);\n    }\n}\nexport function iterateIndexed(action, array) {\n    for (let i = 0; i <= (array.length - 1); i++) {\n        action(i, array[i]);\n    }\n}\nexport function iterate2(action, array1, array2) {\n    if (array1.length !== array2.length) {\n        differentLengths();\n    }\n    for (let i = 0; i <= (array1.length - 1); i++) {\n        action(array1[i], array2[i]);\n    }\n}\nexport function iterateIndexed2(action, array1, array2) {\n    if (array1.length !== array2.length) {\n        differentLengths();\n    }\n    for (let i = 0; i <= (array1.length - 1); i++) {\n        action(i, array1[i], array2[i]);\n    }\n}\nexport function isEmpty(array) {\n    return array.length === 0;\n}\nexport function forAll(predicate, array) {\n    return array.every(predicate);\n}\nexport function permute(f, array) {\n    const size = array.length | 0;\n    const res = array.slice();\n    const checkFlags = new Array(size);\n    iterateIndexed((i, x) => {\n        const j = f(i) | 0;\n        if ((j < 0) ? true : (j >= size)) {\n            throw new Error(\"Not a valid permutation\");\n        }\n        res[j] = x;\n        checkFlags[j] = 1;\n    }, array);\n    if (!(checkFlags.every((y) => (1 === y)))) {\n        throw new Error(\"Not a valid permutation\");\n    }\n    return res;\n}\nexport function setSlice(target, lower, upper, source) {\n    const lower_1 = defaultArg(lower, 0) | 0;\n    const upper_1 = defaultArg(upper, -1) | 0;\n    const length = (((upper_1 >= 0) ? upper_1 : (target.length - 1)) - lower_1) | 0;\n    for (let i = 0; i <= length; i++) {\n        target[i + lower_1] = source[i];\n    }\n}\nexport function sortInPlaceBy(projection, xs, comparer) {\n    xs.sort((x, y) => comparer.Compare(projection(x), projection(y)));\n}\nexport function sortInPlace(xs, comparer) {\n    xs.sort((x, y) => comparer.Compare(x, y));\n}\nexport function sort(xs, comparer) {\n    const xs_1 = xs.slice();\n    xs_1.sort((x, y) => comparer.Compare(x, y));\n    return xs_1;\n}\nexport function sortBy(projection, xs, comparer) {\n    const xs_1 = xs.slice();\n    xs_1.sort((x, y) => comparer.Compare(projection(x), projection(y)));\n    return xs_1;\n}\nexport function sortDescending(xs, comparer) {\n    const xs_1 = xs.slice();\n    xs_1.sort((x, y) => (comparer.Compare(x, y) * -1));\n    return xs_1;\n}\nexport function sortByDescending(projection, xs, comparer) {\n    const xs_1 = xs.slice();\n    xs_1.sort((x, y) => (comparer.Compare(projection(x), projection(y)) * -1));\n    return xs_1;\n}\nexport function sortWith(comparer, xs) {\n    const comparer_1 = comparer;\n    const xs_1 = xs.slice();\n    xs_1.sort(comparer_1);\n    return xs_1;\n}\nexport function allPairs(xs, ys) {\n    const len1 = xs.length | 0;\n    const len2 = ys.length | 0;\n    const res = new Array(len1 * len2);\n    for (let i = 0; i <= (xs.length - 1); i++) {\n        for (let j = 0; j <= (ys.length - 1); j++) {\n            res[(i * len2) + j] = [xs[i], ys[j]];\n        }\n    }\n    return res;\n}\nexport function unfold(generator, state) {\n    const res = [];\n    const loop = (state_1_mut) => {\n        loop: while (true) {\n            const state_1 = state_1_mut;\n            const matchValue = generator(state_1);\n            if (matchValue != null) {\n                const x = value_2(matchValue)[0];\n                const s = value_2(matchValue)[1];\n                res.push(x);\n                state_1_mut = s;\n                continue loop;\n            }\n            break;\n        }\n    };\n    loop(state);\n    return res;\n}\nexport function unzip(array) {\n    const len = array.length | 0;\n    const res1 = new Array(len);\n    const res2 = new Array(len);\n    iterateIndexed((i, tupledArg) => {\n        res1[i] = tupledArg[0];\n        res2[i] = tupledArg[1];\n    }, array);\n    return [res1, res2];\n}\nexport function unzip3(array) {\n    const len = array.length | 0;\n    const res1 = new Array(len);\n    const res2 = new Array(len);\n    const res3 = new Array(len);\n    iterateIndexed((i, tupledArg) => {\n        res1[i] = tupledArg[0];\n        res2[i] = tupledArg[1];\n        res3[i] = tupledArg[2];\n    }, array);\n    return [res1, res2, res3];\n}\nexport function zip(array1, array2) {\n    if (array1.length !== array2.length) {\n        differentLengths();\n    }\n    const result = new Array(array1.length);\n    for (let i = 0; i <= (array1.length - 1); i++) {\n        result[i] = [array1[i], array2[i]];\n    }\n    return result;\n}\nexport function zip3(array1, array2, array3) {\n    if ((array1.length !== array2.length) ? true : (array2.length !== array3.length)) {\n        differentLengths();\n    }\n    const result = new Array(array1.length);\n    for (let i = 0; i <= (array1.length - 1); i++) {\n        result[i] = [array1[i], array2[i], array3[i]];\n    }\n    return result;\n}\nexport function chunkBySize(chunkSize, array) {\n    if (chunkSize < 1) {\n        throw new Error(\"The input must be positive.\\\\nParameter name: size\");\n    }\n    if (array.length === 0) {\n        return [[]];\n    }\n    else {\n        const result = [];\n        for (let x = 0; x <= (~~Math.ceil(array.length / chunkSize) - 1); x++) {\n            let slice;\n            const start_1 = (x * chunkSize) | 0;\n            slice = (array.slice(start_1, (start_1 + chunkSize)));\n            result.push(slice);\n        }\n        return result;\n    }\n}\nexport function splitAt(index, array) {\n    if ((index < 0) ? true : (index > array.length)) {\n        throw new Error((SR_indexOutOfBounds + \"\\\\nParameter name: \") + \"index\");\n    }\n    return [array.slice(0, (0 + index)), array.slice(index)];\n}\nexport function compareWith(comparer, source1, source2) {\n    if (source1 == null) {\n        if (source2 == null) {\n            return 0;\n        }\n        else {\n            return -1;\n        }\n    }\n    else if (source2 == null) {\n        return 1;\n    }\n    else {\n        const len1 = source1.length | 0;\n        const len2 = source2.length | 0;\n        const len = ((len1 < len2) ? len1 : len2) | 0;\n        let i = 0;\n        let res = 0;\n        while ((res === 0) && (i < len)) {\n            res = (comparer(source1[i], source2[i]) | 0);\n            i = ((i + 1) | 0);\n        }\n        if (res !== 0) {\n            return res | 0;\n        }\n        else if (len1 > len2) {\n            return 1;\n        }\n        else if (len1 < len2) {\n            return -1;\n        }\n        else {\n            return 0;\n        }\n    }\n}\nexport function compareTo(comparer, source1, source2) {\n    if (source1 == null) {\n        if (source2 == null) {\n            return 0;\n        }\n        else {\n            return -1;\n        }\n    }\n    else if (source2 == null) {\n        return 1;\n    }\n    else {\n        const len1 = source1.length | 0;\n        const len2 = source2.length | 0;\n        if (len1 > len2) {\n            return 1;\n        }\n        else if (len1 < len2) {\n            return -1;\n        }\n        else {\n            let i = 0;\n            let res = 0;\n            while ((res === 0) && (i < len1)) {\n                res = (comparer(source1[i], source2[i]) | 0);\n                i = ((i + 1) | 0);\n            }\n            return res | 0;\n        }\n    }\n}\nexport function equalsWith(equals, array1, array2) {\n    if (array1 == null) {\n        if (array2 == null) {\n            return true;\n        }\n        else {\n            return false;\n        }\n    }\n    else if (array2 == null) {\n        return false;\n    }\n    else {\n        let i = 0;\n        let result = true;\n        const length1 = array1.length | 0;\n        const length2 = array2.length | 0;\n        if (length1 > length2) {\n            return false;\n        }\n        else if (length1 < length2) {\n            return false;\n        }\n        else {\n            while ((i < length1) && result) {\n                result = equals(array1[i], array2[i]);\n                i = ((i + 1) | 0);\n            }\n            return result;\n        }\n    }\n}\nexport function exactlyOne(array) {\n    switch (array.length) {\n        case 1:\n            return array[0];\n        case 0:\n            throw new Error(\"The input sequence was empty\\\\nParameter name: array\");\n        default:\n            throw new Error(\"Input array too long\\\\nParameter name: array\");\n    }\n}\nexport function tryExactlyOne(array) {\n    if (array.length === 1) {\n        return some(array[0]);\n    }\n    else {\n        return void 0;\n    }\n}\nexport function head(array) {\n    if (array.length === 0) {\n        throw new Error(\"The input array was empty\\\\nParameter name: array\");\n    }\n    else {\n        return array[0];\n    }\n}\nexport function tryHead(array) {\n    if (array.length === 0) {\n        return void 0;\n    }\n    else {\n        return some(array[0]);\n    }\n}\nexport function tail(array) {\n    if (array.length === 0) {\n        throw new Error(\"Not enough elements\\\\nParameter name: array\");\n    }\n    return array.slice(1);\n}\nexport function item(index, array) {\n    return array[index];\n}\nexport function tryItem(index, array) {\n    if ((index < 0) ? true : (index >= array.length)) {\n        return void 0;\n    }\n    else {\n        return some(array[index]);\n    }\n}\nexport function foldBackIndexed(folder, array, state) {\n    return array.reduceRight(((delegateArg, delegateArg_1, delegateArg_2) => folder(delegateArg_2, delegateArg_1, delegateArg)), state);\n}\nexport function foldBack(folder, array, state) {\n    return array.reduceRight(((delegateArg, delegateArg_1) => folder(delegateArg_1, delegateArg)), state);\n}\nexport function foldIndexed2(folder, state, array1, array2) {\n    let acc = state;\n    if (array1.length !== array2.length) {\n        throw new Error(\"Arrays have different lengths\");\n    }\n    for (let i = 0; i <= (array1.length - 1); i++) {\n        acc = folder(i, acc, array1[i], array2[i]);\n    }\n    return acc;\n}\nexport function fold2(folder, state, array1, array2) {\n    return foldIndexed2((_arg, acc, x, y) => folder(acc, x, y), state, array1, array2);\n}\nexport function foldBackIndexed2(folder, array1, array2, state) {\n    let acc = state;\n    if (array1.length !== array2.length) {\n        differentLengths();\n    }\n    const size = array1.length | 0;\n    for (let i = 1; i <= size; i++) {\n        acc = folder(i - 1, array1[size - i], array2[size - i], acc);\n    }\n    return acc;\n}\nexport function foldBack2(f, array1, array2, state) {\n    return foldBackIndexed2((_arg, x, y, acc) => f(x, y, acc), array1, array2, state);\n}\nexport function reduce(reduction, array) {\n    if (array.length === 0) {\n        throw new Error(\"The input array was empty\");\n    }\n    const reduction_1 = reduction;\n    return array.reduce(reduction_1);\n}\nexport function reduceBack(reduction, array) {\n    if (array.length === 0) {\n        throw new Error(\"The input array was empty\");\n    }\n    const reduction_1 = reduction;\n    return array.reduceRight(reduction_1);\n}\nexport function forAll2(predicate, array1, array2) {\n    return fold2((acc, x, y) => (acc && predicate(x, y)), true, array1, array2);\n}\nexport function existsOffset(predicate_mut, array_mut, index_mut) {\n    existsOffset: while (true) {\n        const predicate = predicate_mut, array = array_mut, index = index_mut;\n        if (index === array.length) {\n            return false;\n        }\n        else if (predicate(array[index])) {\n            return true;\n        }\n        else {\n            predicate_mut = predicate;\n            array_mut = array;\n            index_mut = (index + 1);\n            continue existsOffset;\n        }\n        break;\n    }\n}\nexport function exists(predicate, array) {\n    return existsOffset(predicate, array, 0);\n}\nexport function existsOffset2(predicate_mut, array1_mut, array2_mut, index_mut) {\n    existsOffset2: while (true) {\n        const predicate = predicate_mut, array1 = array1_mut, array2 = array2_mut, index = index_mut;\n        if (index === array1.length) {\n            return false;\n        }\n        else if (predicate(array1[index], array2[index])) {\n            return true;\n        }\n        else {\n            predicate_mut = predicate;\n            array1_mut = array1;\n            array2_mut = array2;\n            index_mut = (index + 1);\n            continue existsOffset2;\n        }\n        break;\n    }\n}\nexport function exists2(predicate, array1, array2) {\n    if (array1.length !== array2.length) {\n        differentLengths();\n    }\n    return existsOffset2(predicate, array1, array2, 0);\n}\nexport function sum(array, adder) {\n    let acc = adder.GetZero();\n    for (let i = 0; i <= (array.length - 1); i++) {\n        acc = adder.Add(acc, array[i]);\n    }\n    return acc;\n}\nexport function sumBy(projection, array, adder) {\n    let acc = adder.GetZero();\n    for (let i = 0; i <= (array.length - 1); i++) {\n        acc = adder.Add(acc, projection(array[i]));\n    }\n    return acc;\n}\nexport function maxBy(projection, xs, comparer) {\n    return reduce((x, y) => ((comparer.Compare(projection(y), projection(x)) > 0) ? y : x), xs);\n}\nexport function max(xs, comparer) {\n    return reduce((x, y) => ((comparer.Compare(y, x) > 0) ? y : x), xs);\n}\nexport function minBy(projection, xs, comparer) {\n    return reduce((x, y) => ((comparer.Compare(projection(y), projection(x)) > 0) ? x : y), xs);\n}\nexport function min(xs, comparer) {\n    return reduce((x, y) => ((comparer.Compare(y, x) > 0) ? x : y), xs);\n}\nexport function average(array, averager) {\n    if (array.length === 0) {\n        throw new Error(\"The input array was empty\\\\nParameter name: array\");\n    }\n    let total = averager.GetZero();\n    for (let i = 0; i <= (array.length - 1); i++) {\n        total = averager.Add(total, array[i]);\n    }\n    return averager.DivideByInt(total, array.length);\n}\nexport function averageBy(projection, array, averager) {\n    if (array.length === 0) {\n        throw new Error(\"The input array was empty\\\\nParameter name: array\");\n    }\n    let total = averager.GetZero();\n    for (let i = 0; i <= (array.length - 1); i++) {\n        total = averager.Add(total, projection(array[i]));\n    }\n    return averager.DivideByInt(total, array.length);\n}\nexport function windowed(windowSize, source) {\n    if (windowSize <= 0) {\n        throw new Error(\"windowSize must be positive\");\n    }\n    let res;\n    const len = max_1(0, (source.length - windowSize) + 1) | 0;\n    res = (new Array(len));\n    for (let i = windowSize; i <= source.length; i++) {\n        res[i - windowSize] = source.slice(i - windowSize, (i - 1) + 1);\n    }\n    return res;\n}\nexport function splitInto(chunks, array) {\n    if (chunks < 1) {\n        throw new Error(\"The input must be positive.\\\\nParameter name: chunks\");\n    }\n    if (array.length === 0) {\n        return [[]];\n    }\n    else {\n        const result = [];\n        const chunks_1 = min_1(chunks, array.length) | 0;\n        const minChunkSize = ~~(array.length / chunks_1) | 0;\n        const chunksWithExtraItem = (array.length % chunks_1) | 0;\n        for (let i = 0; i <= (chunks_1 - 1); i++) {\n            const chunkSize = ((i < chunksWithExtraItem) ? (minChunkSize + 1) : minChunkSize) | 0;\n            let slice;\n            const start_1 = ((i * minChunkSize) + min_1(chunksWithExtraItem, i)) | 0;\n            slice = (array.slice(start_1, (start_1 + chunkSize)));\n            result.push(slice);\n        }\n        return result;\n    }\n}\nexport function transpose(arrays, cons) {\n    const arrays_1 = Array.isArray(arrays) ? arrays : (Array.from(arrays));\n    const len = arrays_1.length | 0;\n    if (len === 0) {\n        return new Array(0);\n    }\n    else {\n        const firstArray = arrays_1[0];\n        const lenInner = firstArray.length | 0;\n        if (!forAll((a) => (a.length === lenInner), arrays_1)) {\n            differentLengths();\n        }\n        const result = new Array(lenInner);\n        for (let i = 0; i <= (lenInner - 1); i++) {\n            result[i] = Helpers_allocateArrayFromCons(cons, len);\n            for (let j = 0; j <= (len - 1); j++) {\n                result[i][j] = arrays_1[j][i];\n            }\n        }\n        return result;\n    }\n}\nexport function insertAt(index, y, xs, cons) {\n    const len = xs.length | 0;\n    if ((index < 0) ? true : (index > len)) {\n        throw new Error((SR_indexOutOfBounds + \"\\\\nParameter name: \") + \"index\");\n    }\n    const target = Helpers_allocateArrayFromCons(cons, len + 1);\n    for (let i = 0; i <= (index - 1); i++) {\n        target[i] = xs[i];\n    }\n    target[index] = y;\n    for (let i_1 = index; i_1 <= (len - 1); i_1++) {\n        target[i_1 + 1] = xs[i_1];\n    }\n    return target;\n}\nexport function insertManyAt(index, ys, xs, cons) {\n    const len = xs.length | 0;\n    if ((index < 0) ? true : (index > len)) {\n        throw new Error((SR_indexOutOfBounds + \"\\\\nParameter name: \") + \"index\");\n    }\n    const ys_1 = Array.from(ys);\n    const len2 = ys_1.length | 0;\n    const target = Helpers_allocateArrayFromCons(cons, len + len2);\n    for (let i = 0; i <= (index - 1); i++) {\n        target[i] = xs[i];\n    }\n    for (let i_1 = 0; i_1 <= (len2 - 1); i_1++) {\n        target[index + i_1] = ys_1[i_1];\n    }\n    for (let i_2 = index; i_2 <= (len - 1); i_2++) {\n        target[i_2 + len2] = xs[i_2];\n    }\n    return target;\n}\nexport function removeAt(index, xs) {\n    if ((index < 0) ? true : (index >= xs.length)) {\n        throw new Error((SR_indexOutOfBounds + \"\\\\nParameter name: \") + \"index\");\n    }\n    let i = -1;\n    return filter((_arg) => {\n        i = ((i + 1) | 0);\n        return i !== index;\n    }, xs);\n}\nexport function removeManyAt(index, count, xs) {\n    let i = -1;\n    let status = -1;\n    const ys = filter((_arg) => {\n        i = ((i + 1) | 0);\n        if (i === index) {\n            status = 0;\n            return false;\n        }\n        else if (i > index) {\n            if (i < (index + count)) {\n                return false;\n            }\n            else {\n                status = 1;\n                return true;\n            }\n        }\n        else {\n            return true;\n        }\n    }, xs);\n    const status_1 = (((status === 0) && ((i + 1) === (index + count))) ? 1 : status) | 0;\n    if (status_1 < 1) {\n        throw new Error((SR_indexOutOfBounds + \"\\\\nParameter name: \") + ((status_1 < 0) ? \"index\" : \"count\"));\n    }\n    return ys;\n}\nexport function updateAt(index, y, xs, cons) {\n    const len = xs.length | 0;\n    if ((index < 0) ? true : (index >= len)) {\n        throw new Error((SR_indexOutOfBounds + \"\\\\nParameter name: \") + \"index\");\n    }\n    const target = Helpers_allocateArrayFromCons(cons, len);\n    for (let i = 0; i <= (len - 1); i++) {\n        target[i] = ((i === index) ? y : xs[i]);\n    }\n    return target;\n}\n","export function Helpers_allocateArrayFromCons(cons, len) {\n    if ((typeof cons) === \"function\") {\n        return new cons(len);\n    }\n    else {\n        return new Array(len);\n    }\n}\n","import { FSharpRef } from \"./Types.js\";\nexport function tryParse(str, defValue) {\n    // TODO: test if value is valid and in range\n    if (str != null && /\\S/.test(str)) {\n        const v = +str.replace(\"_\", \"\");\n        if (!Number.isNaN(v)) {\n            defValue.contents = v;\n            return true;\n        }\n    }\n    return false;\n}\nexport function parse(str) {\n    const defValue = new FSharpRef(0);\n    if (tryParse(str, defValue)) {\n        return defValue.contents;\n    }\n    else {\n        throw new Error(`The input string ${str} was not in a correct format.`);\n    }\n}\n// JS Number.isFinite function evals false for NaN\nexport function isPositiveInfinity(x) {\n    return x === Number.POSITIVE_INFINITY;\n}\nexport function isNegativeInfinity(x) {\n    return x === Number.NEGATIVE_INFINITY;\n}\nexport function isInfinity(x) {\n    return x === Number.POSITIVE_INFINITY || x === Number.NEGATIVE_INFINITY;\n}\nexport function max(x, y) {\n    return x > y ? x : y;\n}\nexport function min(x, y) {\n    return x < y ? x : y;\n}\nexport function maxMagnitude(x, y) {\n    return Math.abs(x) > Math.abs(y) ? x : y;\n}\nexport function minMagnitude(x, y) {\n    return Math.abs(x) < Math.abs(y) ? x : y;\n}\nexport function clamp(x, min, max) {\n    return x < min ? min : x > max ? max : x;\n}\n","export const SR_indexOutOfBounds = \"The index was outside the range of elements in the collection.\";\nexport const SR_inputWasEmpty = \"Collection was empty.\";\nexport const SR_inputMustBeNonNegative = \"The input must be non-negative.\";\nexport const SR_inputSequenceEmpty = \"The input sequence was empty.\";\nexport const SR_inputSequenceTooLong = \"The input sequence contains more than one element.\";\nexport const SR_keyNotFoundAlt = \"An index satisfying the predicate was not found in the collection.\";\nexport const SR_differentLengths = \"The collections had different lengths.\";\nexport const SR_notEnoughElements = \"The input sequence has an insufficient number of elements.\";\n","import { join } from \"./String.js\";\nimport { defaultArg, some, value as value_1 } from \"./Option.js\";\nimport { disposeSafe, isArrayLike, defaultOf, toIterator, getEnumerator, compare, structuralHash, equals } from \"./Util.js\";\nimport { Record } from \"./Types.js\";\nimport { class_type, record_type, option_type } from \"./Reflection.js\";\nimport { SR_inputSequenceTooLong, SR_inputSequenceEmpty, SR_inputMustBeNonNegative, SR_notEnoughElements, SR_differentLengths, SR_keyNotFoundAlt, SR_indexOutOfBounds, SR_inputWasEmpty } from \"./Global.js\";\nimport { transpose as transpose_1, splitInto as splitInto_1, windowed as windowed_1, pairwise as pairwise_1, chunkBySize as chunkBySize_1, map as map_1, permute as permute_1, tryFindIndexBack as tryFindIndexBack_1, tryFindBack as tryFindBack_1, scanBack as scanBack_1, foldBack2 as foldBack2_1, foldBack as foldBack_1, fill } from \"./Array.js\";\nexport class FSharpList extends Record {\n    constructor(head, tail) {\n        super();\n        this.head = head;\n        this.tail = tail;\n    }\n    toString() {\n        const xs = this;\n        return (\"[\" + join(\"; \", xs)) + \"]\";\n    }\n    Equals(other) {\n        const xs = this;\n        if (xs === other) {\n            return true;\n        }\n        else {\n            const loop = (xs_1_mut, ys_1_mut) => {\n                loop: while (true) {\n                    const xs_1 = xs_1_mut, ys_1 = ys_1_mut;\n                    const matchValue = xs_1.tail;\n                    const matchValue_1 = ys_1.tail;\n                    if (matchValue != null) {\n                        if (matchValue_1 != null) {\n                            const xt = value_1(matchValue);\n                            const yt = value_1(matchValue_1);\n                            if (equals(xs_1.head, ys_1.head)) {\n                                xs_1_mut = xt;\n                                ys_1_mut = yt;\n                                continue loop;\n                            }\n                            else {\n                                return false;\n                            }\n                        }\n                        else {\n                            return false;\n                        }\n                    }\n                    else if (matchValue_1 != null) {\n                        return false;\n                    }\n                    else {\n                        return true;\n                    }\n                    break;\n                }\n            };\n            return loop(xs, other);\n        }\n    }\n    GetHashCode() {\n        const xs = this;\n        const loop = (i_mut, h_mut, xs_1_mut) => {\n            loop: while (true) {\n                const i = i_mut, h = h_mut, xs_1 = xs_1_mut;\n                const matchValue = xs_1.tail;\n                if (matchValue != null) {\n                    const t = value_1(matchValue);\n                    if (i > 18) {\n                        return h | 0;\n                    }\n                    else {\n                        i_mut = (i + 1);\n                        h_mut = (((h << 1) + structuralHash(xs_1.head)) + (631 * i));\n                        xs_1_mut = t;\n                        continue loop;\n                    }\n                }\n                else {\n                    return h | 0;\n                }\n                break;\n            }\n        };\n        return loop(0, 0, xs) | 0;\n    }\n    toJSON() {\n        const this$ = this;\n        return Array.from(this$);\n    }\n    CompareTo(other) {\n        const xs = this;\n        const loop = (xs_1_mut, ys_1_mut) => {\n            loop: while (true) {\n                const xs_1 = xs_1_mut, ys_1 = ys_1_mut;\n                const matchValue = xs_1.tail;\n                const matchValue_1 = ys_1.tail;\n                if (matchValue != null) {\n                    if (matchValue_1 != null) {\n                        const xt = value_1(matchValue);\n                        const yt = value_1(matchValue_1);\n                        const c = compare(xs_1.head, ys_1.head) | 0;\n                        if (c === 0) {\n                            xs_1_mut = xt;\n                            ys_1_mut = yt;\n                            continue loop;\n                        }\n                        else {\n                            return c | 0;\n                        }\n                    }\n                    else {\n                        return 1;\n                    }\n                }\n                else if (matchValue_1 != null) {\n                    return -1;\n                }\n                else {\n                    return 0;\n                }\n                break;\n            }\n        };\n        return loop(xs, other) | 0;\n    }\n    GetEnumerator() {\n        const xs = this;\n        return ListEnumerator$1_$ctor_3002E699(xs);\n    }\n    [Symbol.iterator]() {\n        return toIterator(getEnumerator(this));\n    }\n    \"System.Collections.IEnumerable.GetEnumerator\"() {\n        const xs = this;\n        return getEnumerator(xs);\n    }\n}\nexport function FSharpList_$reflection(gen0) {\n    return record_type(\"ListModule.FSharpList\", [gen0], FSharpList, () => [[\"head\", gen0], [\"tail\", option_type(FSharpList_$reflection(gen0))]]);\n}\nexport class ListEnumerator$1 {\n    constructor(xs) {\n        this.xs = xs;\n        this.it = this.xs;\n        this.current = defaultOf();\n    }\n    \"System.Collections.Generic.IEnumerator`1.get_Current\"() {\n        const _ = this;\n        return _.current;\n    }\n    \"System.Collections.IEnumerator.get_Current\"() {\n        const _ = this;\n        return _.current;\n    }\n    \"System.Collections.IEnumerator.MoveNext\"() {\n        const _ = this;\n        const matchValue = _.it.tail;\n        if (matchValue != null) {\n            const t = value_1(matchValue);\n            _.current = _.it.head;\n            _.it = t;\n            return true;\n        }\n        else {\n            return false;\n        }\n    }\n    \"System.Collections.IEnumerator.Reset\"() {\n        const _ = this;\n        _.it = _.xs;\n        _.current = defaultOf();\n    }\n    Dispose() {\n    }\n}\nexport function ListEnumerator$1_$reflection(gen0) {\n    return class_type(\"ListModule.ListEnumerator`1\", [gen0], ListEnumerator$1);\n}\nexport function ListEnumerator$1_$ctor_3002E699(xs) {\n    return new ListEnumerator$1(xs);\n}\nexport function FSharpList_get_Empty() {\n    return new FSharpList(defaultOf(), void 0);\n}\nexport function FSharpList_Cons_305B8EAC(x, xs) {\n    return new FSharpList(x, xs);\n}\nexport function FSharpList__get_IsEmpty(xs) {\n    return xs.tail == null;\n}\nexport function FSharpList__get_Length(xs) {\n    const loop = (i_mut, xs_1_mut) => {\n        loop: while (true) {\n            const i = i_mut, xs_1 = xs_1_mut;\n            const matchValue = xs_1.tail;\n            if (matchValue != null) {\n                i_mut = (i + 1);\n                xs_1_mut = value_1(matchValue);\n                continue loop;\n            }\n            else {\n                return i | 0;\n            }\n            break;\n        }\n    };\n    return loop(0, xs) | 0;\n}\nexport function FSharpList__get_Head(xs) {\n    const matchValue = xs.tail;\n    if (matchValue != null) {\n        return xs.head;\n    }\n    else {\n        throw new Error((SR_inputWasEmpty + \"\\\\nParameter name: \") + \"list\");\n    }\n}\nexport function FSharpList__get_Tail(xs) {\n    const matchValue = xs.tail;\n    if (matchValue != null) {\n        return value_1(matchValue);\n    }\n    else {\n        throw new Error((SR_inputWasEmpty + \"\\\\nParameter name: \") + \"list\");\n    }\n}\nexport function FSharpList__get_Item_Z524259A4(xs, index) {\n    const loop = (i_mut, xs_1_mut) => {\n        loop: while (true) {\n            const i = i_mut, xs_1 = xs_1_mut;\n            const matchValue = xs_1.tail;\n            if (matchValue != null) {\n                if (i === index) {\n                    return xs_1.head;\n                }\n                else {\n                    i_mut = (i + 1);\n                    xs_1_mut = value_1(matchValue);\n                    continue loop;\n                }\n            }\n            else {\n                throw new Error((SR_indexOutOfBounds + \"\\\\nParameter name: \") + \"index\");\n            }\n            break;\n        }\n    };\n    return loop(0, xs);\n}\nexport function indexNotFound() {\n    throw new Error(SR_keyNotFoundAlt);\n}\nexport function empty() {\n    return FSharpList_get_Empty();\n}\nexport function cons(x, xs) {\n    return FSharpList_Cons_305B8EAC(x, xs);\n}\nexport function singleton(x) {\n    return FSharpList_Cons_305B8EAC(x, FSharpList_get_Empty());\n}\nexport function isEmpty(xs) {\n    return FSharpList__get_IsEmpty(xs);\n}\nexport function length(xs) {\n    return FSharpList__get_Length(xs);\n}\nexport function head(xs) {\n    return FSharpList__get_Head(xs);\n}\nexport function tryHead(xs) {\n    if (FSharpList__get_IsEmpty(xs)) {\n        return void 0;\n    }\n    else {\n        return some(FSharpList__get_Head(xs));\n    }\n}\nexport function tail(xs) {\n    return FSharpList__get_Tail(xs);\n}\nexport function tryLast(xs_mut) {\n    tryLast: while (true) {\n        const xs = xs_mut;\n        if (FSharpList__get_IsEmpty(xs)) {\n            return void 0;\n        }\n        else {\n            const t = FSharpList__get_Tail(xs);\n            if (FSharpList__get_IsEmpty(t)) {\n                return some(FSharpList__get_Head(xs));\n            }\n            else {\n                xs_mut = t;\n                continue tryLast;\n            }\n        }\n        break;\n    }\n}\nexport function last(xs) {\n    const matchValue = tryLast(xs);\n    if (matchValue == null) {\n        throw new Error(SR_inputWasEmpty);\n    }\n    else {\n        return value_1(matchValue);\n    }\n}\nexport function compareWith(comparer, xs, ys) {\n    const loop = (xs_1_mut, ys_1_mut) => {\n        loop: while (true) {\n            const xs_1 = xs_1_mut, ys_1 = ys_1_mut;\n            const matchValue = FSharpList__get_IsEmpty(xs_1);\n            const matchValue_1 = FSharpList__get_IsEmpty(ys_1);\n            if (matchValue) {\n                if (matchValue_1) {\n                    return 0;\n                }\n                else {\n                    return -1;\n                }\n            }\n            else if (matchValue_1) {\n                return 1;\n            }\n            else {\n                const c = comparer(FSharpList__get_Head(xs_1), FSharpList__get_Head(ys_1)) | 0;\n                if (c === 0) {\n                    xs_1_mut = FSharpList__get_Tail(xs_1);\n                    ys_1_mut = FSharpList__get_Tail(ys_1);\n                    continue loop;\n                }\n                else {\n                    return c | 0;\n                }\n            }\n            break;\n        }\n    };\n    return loop(xs, ys) | 0;\n}\nexport function toArray(xs) {\n    const len = FSharpList__get_Length(xs) | 0;\n    const res = fill(new Array(len), 0, len, null);\n    const loop = (i_mut, xs_1_mut) => {\n        loop: while (true) {\n            const i = i_mut, xs_1 = xs_1_mut;\n            if (!FSharpList__get_IsEmpty(xs_1)) {\n                res[i] = FSharpList__get_Head(xs_1);\n                i_mut = (i + 1);\n                xs_1_mut = FSharpList__get_Tail(xs_1);\n                continue loop;\n            }\n            break;\n        }\n    };\n    loop(0, xs);\n    return res;\n}\nexport function fold(folder, state, xs) {\n    let acc = state;\n    let xs_1 = xs;\n    while (!FSharpList__get_IsEmpty(xs_1)) {\n        acc = folder(acc, head(xs_1));\n        xs_1 = FSharpList__get_Tail(xs_1);\n    }\n    return acc;\n}\nexport function reverse(xs) {\n    return fold((acc, x) => FSharpList_Cons_305B8EAC(x, acc), FSharpList_get_Empty(), xs);\n}\nexport function foldBack(folder, xs, state) {\n    return foldBack_1(folder, toArray(xs), state);\n}\nexport function foldIndexed(folder, state, xs) {\n    const loop = (i_mut, acc_mut, xs_1_mut) => {\n        loop: while (true) {\n            const i = i_mut, acc = acc_mut, xs_1 = xs_1_mut;\n            if (FSharpList__get_IsEmpty(xs_1)) {\n                return acc;\n            }\n            else {\n                i_mut = (i + 1);\n                acc_mut = folder(i, acc, FSharpList__get_Head(xs_1));\n                xs_1_mut = FSharpList__get_Tail(xs_1);\n                continue loop;\n            }\n            break;\n        }\n    };\n    return loop(0, state, xs);\n}\nexport function fold2(folder, state, xs, ys) {\n    let acc = state;\n    let xs_1 = xs;\n    let ys_1 = ys;\n    while (!FSharpList__get_IsEmpty(xs_1) && !FSharpList__get_IsEmpty(ys_1)) {\n        acc = folder(acc, FSharpList__get_Head(xs_1), FSharpList__get_Head(ys_1));\n        xs_1 = FSharpList__get_Tail(xs_1);\n        ys_1 = FSharpList__get_Tail(ys_1);\n    }\n    return acc;\n}\nexport function foldBack2(folder, xs, ys, state) {\n    return foldBack2_1(folder, toArray(xs), toArray(ys), state);\n}\nexport function unfold(gen, state) {\n    const loop = (acc_mut, node_mut) => {\n        let t;\n        loop: while (true) {\n            const acc = acc_mut, node = node_mut;\n            const matchValue = gen(acc);\n            if (matchValue != null) {\n                acc_mut = value_1(matchValue)[1];\n                node_mut = ((t = (new FSharpList(value_1(matchValue)[0], void 0)), (node.tail = t, t)));\n                continue loop;\n            }\n            else {\n                return node;\n            }\n            break;\n        }\n    };\n    const root = FSharpList_get_Empty();\n    const node_1 = loop(state, root);\n    const t_2 = FSharpList_get_Empty();\n    node_1.tail = t_2;\n    return FSharpList__get_Tail(root);\n}\nexport function iterate(action, xs) {\n    fold((unitVar, x) => {\n        action(x);\n    }, void 0, xs);\n}\nexport function iterate2(action, xs, ys) {\n    fold2((unitVar, x, y) => {\n        action(x, y);\n    }, void 0, xs, ys);\n}\nexport function iterateIndexed(action, xs) {\n    fold((i, x) => {\n        action(i, x);\n        return (i + 1) | 0;\n    }, 0, xs);\n}\nexport function iterateIndexed2(action, xs, ys) {\n    fold2((i, x, y) => {\n        action(i, x, y);\n        return (i + 1) | 0;\n    }, 0, xs, ys);\n}\nexport function toSeq(xs) {\n    return xs;\n}\nexport function ofArrayWithTail(xs, tail_1) {\n    let res = tail_1;\n    for (let i = xs.length - 1; i >= 0; i--) {\n        res = FSharpList_Cons_305B8EAC(xs[i], res);\n    }\n    return res;\n}\nexport function ofArray(xs) {\n    return ofArrayWithTail(xs, FSharpList_get_Empty());\n}\nexport function ofSeq(xs) {\n    let xs_3, t;\n    if (isArrayLike(xs)) {\n        return ofArray(xs);\n    }\n    else if (xs instanceof FSharpList) {\n        return xs;\n    }\n    else {\n        const root = FSharpList_get_Empty();\n        let node = root;\n        const enumerator = getEnumerator(xs);\n        try {\n            while (enumerator[\"System.Collections.IEnumerator.MoveNext\"]()) {\n                const x = enumerator[\"System.Collections.Generic.IEnumerator`1.get_Current\"]();\n                node = ((xs_3 = node, (t = (new FSharpList(x, void 0)), (xs_3.tail = t, t))));\n            }\n        }\n        finally {\n            disposeSafe(enumerator);\n        }\n        const xs_5 = node;\n        const t_2 = FSharpList_get_Empty();\n        xs_5.tail = t_2;\n        return FSharpList__get_Tail(root);\n    }\n}\nexport function concat(lists) {\n    const root = FSharpList_get_Empty();\n    let node = root;\n    const action = (xs) => {\n        node = fold((acc, x) => {\n            const t = new FSharpList(x, void 0);\n            acc.tail = t;\n            return t;\n        }, node, xs);\n    };\n    if (isArrayLike(lists)) {\n        const xs_3 = lists;\n        xs_3.forEach(action);\n    }\n    else if (lists instanceof FSharpList) {\n        iterate(action, lists);\n    }\n    else {\n        const enumerator = getEnumerator(lists);\n        try {\n            while (enumerator[\"System.Collections.IEnumerator.MoveNext\"]()) {\n                action(enumerator[\"System.Collections.Generic.IEnumerator`1.get_Current\"]());\n            }\n        }\n        finally {\n            disposeSafe(enumerator);\n        }\n    }\n    const xs_6 = node;\n    const t_2 = FSharpList_get_Empty();\n    xs_6.tail = t_2;\n    return FSharpList__get_Tail(root);\n}\nexport function scan(folder, state, xs) {\n    let xs_4, t_2;\n    const root = FSharpList_get_Empty();\n    let node;\n    const t = new FSharpList(state, void 0);\n    root.tail = t;\n    node = t;\n    let acc = state;\n    let xs_3 = xs;\n    while (!FSharpList__get_IsEmpty(xs_3)) {\n        acc = folder(acc, FSharpList__get_Head(xs_3));\n        node = ((xs_4 = node, (t_2 = (new FSharpList(acc, void 0)), (xs_4.tail = t_2, t_2))));\n        xs_3 = FSharpList__get_Tail(xs_3);\n    }\n    const xs_6 = node;\n    const t_4 = FSharpList_get_Empty();\n    xs_6.tail = t_4;\n    return FSharpList__get_Tail(root);\n}\nexport function scanBack(folder, xs, state) {\n    return ofArray(scanBack_1(folder, toArray(xs), state));\n}\nexport function append(xs, ys) {\n    return fold((acc, x) => FSharpList_Cons_305B8EAC(x, acc), ys, reverse(xs));\n}\nexport function collect(mapping, xs) {\n    let xs_1, t;\n    const root = FSharpList_get_Empty();\n    let node = root;\n    let ys = xs;\n    while (!FSharpList__get_IsEmpty(ys)) {\n        let zs = mapping(FSharpList__get_Head(ys));\n        while (!FSharpList__get_IsEmpty(zs)) {\n            node = ((xs_1 = node, (t = (new FSharpList(FSharpList__get_Head(zs), void 0)), (xs_1.tail = t, t))));\n            zs = FSharpList__get_Tail(zs);\n        }\n        ys = FSharpList__get_Tail(ys);\n    }\n    const xs_3 = node;\n    const t_2 = FSharpList_get_Empty();\n    xs_3.tail = t_2;\n    return FSharpList__get_Tail(root);\n}\nexport function mapIndexed(mapping, xs) {\n    const root = FSharpList_get_Empty();\n    const node = foldIndexed((i, acc, x) => {\n        const t = new FSharpList(mapping(i, x), void 0);\n        acc.tail = t;\n        return t;\n    }, root, xs);\n    const t_2 = FSharpList_get_Empty();\n    node.tail = t_2;\n    return FSharpList__get_Tail(root);\n}\nexport function map(mapping, xs) {\n    const root = FSharpList_get_Empty();\n    const node = fold((acc, x) => {\n        const t = new FSharpList(mapping(x), void 0);\n        acc.tail = t;\n        return t;\n    }, root, xs);\n    const t_2 = FSharpList_get_Empty();\n    node.tail = t_2;\n    return FSharpList__get_Tail(root);\n}\nexport function indexed(xs) {\n    return mapIndexed((i, x) => [i, x], xs);\n}\nexport function map2(mapping, xs, ys) {\n    const root = FSharpList_get_Empty();\n    const node = fold2((acc, x, y) => {\n        const t = new FSharpList(mapping(x, y), void 0);\n        acc.tail = t;\n        return t;\n    }, root, xs, ys);\n    const t_2 = FSharpList_get_Empty();\n    node.tail = t_2;\n    return FSharpList__get_Tail(root);\n}\nexport function mapIndexed2(mapping, xs, ys) {\n    const loop = (i_mut, acc_mut, xs_1_mut, ys_1_mut) => {\n        let t;\n        loop: while (true) {\n            const i = i_mut, acc = acc_mut, xs_1 = xs_1_mut, ys_1 = ys_1_mut;\n            if (FSharpList__get_IsEmpty(xs_1) ? true : FSharpList__get_IsEmpty(ys_1)) {\n                return acc;\n            }\n            else {\n                i_mut = (i + 1);\n                acc_mut = ((t = (new FSharpList(mapping(i, FSharpList__get_Head(xs_1), FSharpList__get_Head(ys_1)), void 0)), (acc.tail = t, t)));\n                xs_1_mut = FSharpList__get_Tail(xs_1);\n                ys_1_mut = FSharpList__get_Tail(ys_1);\n                continue loop;\n            }\n            break;\n        }\n    };\n    const root = FSharpList_get_Empty();\n    const node_1 = loop(0, root, xs, ys);\n    const t_2 = FSharpList_get_Empty();\n    node_1.tail = t_2;\n    return FSharpList__get_Tail(root);\n}\nexport function map3(mapping, xs, ys, zs) {\n    const loop = (acc_mut, xs_1_mut, ys_1_mut, zs_1_mut) => {\n        let t;\n        loop: while (true) {\n            const acc = acc_mut, xs_1 = xs_1_mut, ys_1 = ys_1_mut, zs_1 = zs_1_mut;\n            if ((FSharpList__get_IsEmpty(xs_1) ? true : FSharpList__get_IsEmpty(ys_1)) ? true : FSharpList__get_IsEmpty(zs_1)) {\n                return acc;\n            }\n            else {\n                acc_mut = ((t = (new FSharpList(mapping(FSharpList__get_Head(xs_1), FSharpList__get_Head(ys_1), FSharpList__get_Head(zs_1)), void 0)), (acc.tail = t, t)));\n                xs_1_mut = FSharpList__get_Tail(xs_1);\n                ys_1_mut = FSharpList__get_Tail(ys_1);\n                zs_1_mut = FSharpList__get_Tail(zs_1);\n                continue loop;\n            }\n            break;\n        }\n    };\n    const root = FSharpList_get_Empty();\n    const node_1 = loop(root, xs, ys, zs);\n    const t_2 = FSharpList_get_Empty();\n    node_1.tail = t_2;\n    return FSharpList__get_Tail(root);\n}\nexport function mapFold(mapping, state, xs) {\n    const root = FSharpList_get_Empty();\n    const patternInput_1 = fold((tupledArg, x) => {\n        let t;\n        const patternInput = mapping(tupledArg[1], x);\n        return [(t = (new FSharpList(patternInput[0], void 0)), (tupledArg[0].tail = t, t)), patternInput[1]];\n    }, [root, state], xs);\n    const t_2 = FSharpList_get_Empty();\n    patternInput_1[0].tail = t_2;\n    return [FSharpList__get_Tail(root), patternInput_1[1]];\n}\nexport function mapFoldBack(mapping, xs, state) {\n    return mapFold((acc, x) => mapping(x, acc), state, reverse(xs));\n}\nexport function tryPick(f, xs) {\n    const loop = (xs_1_mut) => {\n        loop: while (true) {\n            const xs_1 = xs_1_mut;\n            if (FSharpList__get_IsEmpty(xs_1)) {\n                return void 0;\n            }\n            else {\n                const matchValue = f(FSharpList__get_Head(xs_1));\n                if (matchValue == null) {\n                    xs_1_mut = FSharpList__get_Tail(xs_1);\n                    continue loop;\n                }\n                else {\n                    return matchValue;\n                }\n            }\n            break;\n        }\n    };\n    return loop(xs);\n}\nexport function pick(f, xs) {\n    const matchValue = tryPick(f, xs);\n    if (matchValue == null) {\n        return indexNotFound();\n    }\n    else {\n        return value_1(matchValue);\n    }\n}\nexport function tryFind(f, xs) {\n    return tryPick((x) => (f(x) ? some(x) : void 0), xs);\n}\nexport function find(f, xs) {\n    const matchValue = tryFind(f, xs);\n    if (matchValue == null) {\n        return indexNotFound();\n    }\n    else {\n        return value_1(matchValue);\n    }\n}\nexport function tryFindBack(f, xs) {\n    return tryFindBack_1(f, toArray(xs));\n}\nexport function findBack(f, xs) {\n    const matchValue = tryFindBack(f, xs);\n    if (matchValue == null) {\n        return indexNotFound();\n    }\n    else {\n        return value_1(matchValue);\n    }\n}\nexport function tryFindIndex(f, xs) {\n    const loop = (i_mut, xs_1_mut) => {\n        loop: while (true) {\n            const i = i_mut, xs_1 = xs_1_mut;\n            if (FSharpList__get_IsEmpty(xs_1)) {\n                return void 0;\n            }\n            else if (f(FSharpList__get_Head(xs_1))) {\n                return i;\n            }\n            else {\n                i_mut = (i + 1);\n                xs_1_mut = FSharpList__get_Tail(xs_1);\n                continue loop;\n            }\n            break;\n        }\n    };\n    return loop(0, xs);\n}\nexport function findIndex(f, xs) {\n    const matchValue = tryFindIndex(f, xs);\n    if (matchValue == null) {\n        indexNotFound();\n        return -1;\n    }\n    else {\n        return value_1(matchValue) | 0;\n    }\n}\nexport function tryFindIndexBack(f, xs) {\n    return tryFindIndexBack_1(f, toArray(xs));\n}\nexport function findIndexBack(f, xs) {\n    const matchValue = tryFindIndexBack(f, xs);\n    if (matchValue == null) {\n        indexNotFound();\n        return -1;\n    }\n    else {\n        return value_1(matchValue) | 0;\n    }\n}\nexport function tryItem(n, xs) {\n    const loop = (i_mut, xs_1_mut) => {\n        loop: while (true) {\n            const i = i_mut, xs_1 = xs_1_mut;\n            if (FSharpList__get_IsEmpty(xs_1)) {\n                return void 0;\n            }\n            else if (i === n) {\n                return some(FSharpList__get_Head(xs_1));\n            }\n            else {\n                i_mut = (i + 1);\n                xs_1_mut = FSharpList__get_Tail(xs_1);\n                continue loop;\n            }\n            break;\n        }\n    };\n    return loop(0, xs);\n}\nexport function item(n, xs) {\n    return FSharpList__get_Item_Z524259A4(xs, n);\n}\nexport function filter(f, xs) {\n    const root = FSharpList_get_Empty();\n    const node = fold((acc, x) => {\n        if (f(x)) {\n            const t = new FSharpList(x, void 0);\n            acc.tail = t;\n            return t;\n        }\n        else {\n            return acc;\n        }\n    }, root, xs);\n    const t_2 = FSharpList_get_Empty();\n    node.tail = t_2;\n    return FSharpList__get_Tail(root);\n}\nexport function partition(f, xs) {\n    const matchValue = FSharpList_get_Empty();\n    const root2 = FSharpList_get_Empty();\n    const root1 = matchValue;\n    const patternInput_1 = fold((tupledArg, x) => {\n        let t, t_2;\n        const lacc = tupledArg[0];\n        const racc = tupledArg[1];\n        if (f(x)) {\n            return [(t = (new FSharpList(x, void 0)), (lacc.tail = t, t)), racc];\n        }\n        else {\n            return [lacc, (t_2 = (new FSharpList(x, void 0)), (racc.tail = t_2, t_2))];\n        }\n    }, [root1, root2], xs);\n    const t_4 = FSharpList_get_Empty();\n    patternInput_1[0].tail = t_4;\n    const t_5 = FSharpList_get_Empty();\n    patternInput_1[1].tail = t_5;\n    return [FSharpList__get_Tail(root1), FSharpList__get_Tail(root2)];\n}\nexport function choose(f, xs) {\n    const root = FSharpList_get_Empty();\n    const node = fold((acc, x) => {\n        const matchValue = f(x);\n        if (matchValue == null) {\n            return acc;\n        }\n        else {\n            const t = new FSharpList(value_1(matchValue), void 0);\n            acc.tail = t;\n            return t;\n        }\n    }, root, xs);\n    const t_2 = FSharpList_get_Empty();\n    node.tail = t_2;\n    return FSharpList__get_Tail(root);\n}\nexport function contains(value, xs, eq) {\n    return tryFindIndex((v) => eq.Equals(value, v), xs) != null;\n}\nexport function initialize(n, f) {\n    let xs, t;\n    const root = FSharpList_get_Empty();\n    let node = root;\n    for (let i = 0; i <= (n - 1); i++) {\n        node = ((xs = node, (t = (new FSharpList(f(i), void 0)), (xs.tail = t, t))));\n    }\n    const xs_2 = node;\n    const t_2 = FSharpList_get_Empty();\n    xs_2.tail = t_2;\n    return FSharpList__get_Tail(root);\n}\nexport function replicate(n, x) {\n    return initialize(n, (_arg) => x);\n}\nexport function reduce(f, xs) {\n    if (FSharpList__get_IsEmpty(xs)) {\n        throw new Error(SR_inputWasEmpty);\n    }\n    else {\n        return fold(f, head(xs), tail(xs));\n    }\n}\nexport function reduceBack(f, xs) {\n    if (FSharpList__get_IsEmpty(xs)) {\n        throw new Error(SR_inputWasEmpty);\n    }\n    else {\n        return foldBack(f, tail(xs), head(xs));\n    }\n}\nexport function forAll(f, xs) {\n    return fold((acc, x) => (acc && f(x)), true, xs);\n}\nexport function forAll2(f, xs, ys) {\n    return fold2((acc, x, y) => (acc && f(x, y)), true, xs, ys);\n}\nexport function exists(f, xs) {\n    return tryFindIndex(f, xs) != null;\n}\nexport function exists2(f_mut, xs_mut, ys_mut) {\n    exists2: while (true) {\n        const f = f_mut, xs = xs_mut, ys = ys_mut;\n        const matchValue = FSharpList__get_IsEmpty(xs);\n        const matchValue_1 = FSharpList__get_IsEmpty(ys);\n        let matchResult;\n        if (matchValue) {\n            if (matchValue_1) {\n                matchResult = 0;\n            }\n            else {\n                matchResult = 2;\n            }\n        }\n        else if (matchValue_1) {\n            matchResult = 2;\n        }\n        else {\n            matchResult = 1;\n        }\n        switch (matchResult) {\n            case 0:\n                return false;\n            case 1:\n                if (f(FSharpList__get_Head(xs), FSharpList__get_Head(ys))) {\n                    return true;\n                }\n                else {\n                    f_mut = f;\n                    xs_mut = FSharpList__get_Tail(xs);\n                    ys_mut = FSharpList__get_Tail(ys);\n                    continue exists2;\n                }\n            default:\n                throw new Error((SR_differentLengths + \"\\\\nParameter name: \") + \"list2\");\n        }\n        break;\n    }\n}\nexport function unzip(xs) {\n    return foldBack((tupledArg, tupledArg_1) => [FSharpList_Cons_305B8EAC(tupledArg[0], tupledArg_1[0]), FSharpList_Cons_305B8EAC(tupledArg[1], tupledArg_1[1])], xs, [FSharpList_get_Empty(), FSharpList_get_Empty()]);\n}\nexport function unzip3(xs) {\n    return foldBack((tupledArg, tupledArg_1) => [FSharpList_Cons_305B8EAC(tupledArg[0], tupledArg_1[0]), FSharpList_Cons_305B8EAC(tupledArg[1], tupledArg_1[1]), FSharpList_Cons_305B8EAC(tupledArg[2], tupledArg_1[2])], xs, [FSharpList_get_Empty(), FSharpList_get_Empty(), FSharpList_get_Empty()]);\n}\nexport function zip(xs, ys) {\n    return map2((x, y) => [x, y], xs, ys);\n}\nexport function zip3(xs, ys, zs) {\n    return map3((x, y, z) => [x, y, z], xs, ys, zs);\n}\nexport function sortWith(comparer, xs) {\n    const arr = toArray(xs);\n    arr.sort(comparer);\n    return ofArray(arr);\n}\nexport function sort(xs, comparer) {\n    return sortWith((x, y) => comparer.Compare(x, y), xs);\n}\nexport function sortBy(projection, xs, comparer) {\n    return sortWith((x, y) => comparer.Compare(projection(x), projection(y)), xs);\n}\nexport function sortDescending(xs, comparer) {\n    return sortWith((x, y) => (comparer.Compare(x, y) * -1), xs);\n}\nexport function sortByDescending(projection, xs, comparer) {\n    return sortWith((x, y) => (comparer.Compare(projection(x), projection(y)) * -1), xs);\n}\nexport function sum(xs, adder) {\n    return fold((acc, x) => adder.Add(acc, x), adder.GetZero(), xs);\n}\nexport function sumBy(f, xs, adder) {\n    return fold((acc, x) => adder.Add(acc, f(x)), adder.GetZero(), xs);\n}\nexport function maxBy(projection, xs, comparer) {\n    return reduce((x, y) => ((comparer.Compare(projection(y), projection(x)) > 0) ? y : x), xs);\n}\nexport function max(xs, comparer) {\n    return reduce((x, y) => ((comparer.Compare(y, x) > 0) ? y : x), xs);\n}\nexport function minBy(projection, xs, comparer) {\n    return reduce((x, y) => ((comparer.Compare(projection(y), projection(x)) > 0) ? x : y), xs);\n}\nexport function min(xs, comparer) {\n    return reduce((x, y) => ((comparer.Compare(y, x) > 0) ? x : y), xs);\n}\nexport function average(xs, averager) {\n    let count = 0;\n    const total = fold((acc, x) => {\n        count = ((count + 1) | 0);\n        return averager.Add(acc, x);\n    }, averager.GetZero(), xs);\n    return averager.DivideByInt(total, count);\n}\nexport function averageBy(f, xs, averager) {\n    let count = 0;\n    const total = fold((acc, x) => {\n        count = ((count + 1) | 0);\n        return averager.Add(acc, f(x));\n    }, averager.GetZero(), xs);\n    return averager.DivideByInt(total, count);\n}\nexport function permute(f, xs) {\n    return ofArray(permute_1(f, toArray(xs)));\n}\nexport function chunkBySize(chunkSize, xs) {\n    return ofArray(map_1(ofArray, chunkBySize_1(chunkSize, toArray(xs))));\n}\nexport function allPairs(xs, ys) {\n    const root = FSharpList_get_Empty();\n    let node = root;\n    iterate((x) => {\n        iterate((y) => {\n            let xs_1, t;\n            node = ((xs_1 = node, (t = (new FSharpList([x, y], void 0)), (xs_1.tail = t, t))));\n        }, ys);\n    }, xs);\n    const xs_3 = node;\n    const t_2 = FSharpList_get_Empty();\n    xs_3.tail = t_2;\n    return FSharpList__get_Tail(root);\n}\nexport function skip(count_mut, xs_mut) {\n    skip: while (true) {\n        const count = count_mut, xs = xs_mut;\n        if (count <= 0) {\n            return xs;\n        }\n        else if (FSharpList__get_IsEmpty(xs)) {\n            throw new Error((SR_notEnoughElements + \"\\\\nParameter name: \") + \"list\");\n        }\n        else {\n            count_mut = (count - 1);\n            xs_mut = FSharpList__get_Tail(xs);\n            continue skip;\n        }\n        break;\n    }\n}\nexport function skipWhile(predicate_mut, xs_mut) {\n    skipWhile: while (true) {\n        const predicate = predicate_mut, xs = xs_mut;\n        if (FSharpList__get_IsEmpty(xs)) {\n            return xs;\n        }\n        else if (!predicate(FSharpList__get_Head(xs))) {\n            return xs;\n        }\n        else {\n            predicate_mut = predicate;\n            xs_mut = FSharpList__get_Tail(xs);\n            continue skipWhile;\n        }\n        break;\n    }\n}\nexport function take(count, xs) {\n    if (count < 0) {\n        throw new Error((SR_inputMustBeNonNegative + \"\\\\nParameter name: \") + \"count\");\n    }\n    const loop = (i_mut, acc_mut, xs_1_mut) => {\n        let t;\n        loop: while (true) {\n            const i = i_mut, acc = acc_mut, xs_1 = xs_1_mut;\n            if (i <= 0) {\n                return acc;\n            }\n            else if (FSharpList__get_IsEmpty(xs_1)) {\n                throw new Error((SR_notEnoughElements + \"\\\\nParameter name: \") + \"list\");\n            }\n            else {\n                i_mut = (i - 1);\n                acc_mut = ((t = (new FSharpList(FSharpList__get_Head(xs_1), void 0)), (acc.tail = t, t)));\n                xs_1_mut = FSharpList__get_Tail(xs_1);\n                continue loop;\n            }\n            break;\n        }\n    };\n    const root = FSharpList_get_Empty();\n    const node = loop(count, root, xs);\n    const t_2 = FSharpList_get_Empty();\n    node.tail = t_2;\n    return FSharpList__get_Tail(root);\n}\nexport function takeWhile(predicate, xs) {\n    const loop = (acc_mut, xs_1_mut) => {\n        let t;\n        loop: while (true) {\n            const acc = acc_mut, xs_1 = xs_1_mut;\n            if (FSharpList__get_IsEmpty(xs_1)) {\n                return acc;\n            }\n            else if (!predicate(FSharpList__get_Head(xs_1))) {\n                return acc;\n            }\n            else {\n                acc_mut = ((t = (new FSharpList(FSharpList__get_Head(xs_1), void 0)), (acc.tail = t, t)));\n                xs_1_mut = FSharpList__get_Tail(xs_1);\n                continue loop;\n            }\n            break;\n        }\n    };\n    const root = FSharpList_get_Empty();\n    const node = loop(root, xs);\n    const t_2 = FSharpList_get_Empty();\n    node.tail = t_2;\n    return FSharpList__get_Tail(root);\n}\nexport function truncate(count, xs) {\n    const loop = (i_mut, acc_mut, xs_1_mut) => {\n        let t;\n        loop: while (true) {\n            const i = i_mut, acc = acc_mut, xs_1 = xs_1_mut;\n            if (i <= 0) {\n                return acc;\n            }\n            else if (FSharpList__get_IsEmpty(xs_1)) {\n                return acc;\n            }\n            else {\n                i_mut = (i - 1);\n                acc_mut = ((t = (new FSharpList(FSharpList__get_Head(xs_1), void 0)), (acc.tail = t, t)));\n                xs_1_mut = FSharpList__get_Tail(xs_1);\n                continue loop;\n            }\n            break;\n        }\n    };\n    const root = FSharpList_get_Empty();\n    const node = loop(count, root, xs);\n    const t_2 = FSharpList_get_Empty();\n    node.tail = t_2;\n    return FSharpList__get_Tail(root);\n}\nexport function getSlice(startIndex, endIndex, xs) {\n    const len = length(xs) | 0;\n    let startIndex_1;\n    const index = defaultArg(startIndex, 0) | 0;\n    startIndex_1 = ((index < 0) ? 0 : index);\n    let endIndex_1;\n    const index_1 = defaultArg(endIndex, len - 1) | 0;\n    endIndex_1 = ((index_1 >= len) ? (len - 1) : index_1);\n    if (endIndex_1 < startIndex_1) {\n        return FSharpList_get_Empty();\n    }\n    else {\n        return take((endIndex_1 - startIndex_1) + 1, skip(startIndex_1, xs));\n    }\n}\nexport function splitAt(index, xs) {\n    if (index < 0) {\n        throw new Error((SR_inputMustBeNonNegative + \"\\\\nParameter name: \") + \"index\");\n    }\n    if (index > FSharpList__get_Length(xs)) {\n        throw new Error((SR_notEnoughElements + \"\\\\nParameter name: \") + \"index\");\n    }\n    return [take(index, xs), skip(index, xs)];\n}\nexport function exactlyOne(xs) {\n    if (FSharpList__get_IsEmpty(xs)) {\n        throw new Error((SR_inputSequenceEmpty + \"\\\\nParameter name: \") + \"list\");\n    }\n    else if (FSharpList__get_IsEmpty(FSharpList__get_Tail(xs))) {\n        return FSharpList__get_Head(xs);\n    }\n    else {\n        throw new Error((SR_inputSequenceTooLong + \"\\\\nParameter name: \") + \"list\");\n    }\n}\nexport function tryExactlyOne(xs) {\n    if (!FSharpList__get_IsEmpty(xs) && FSharpList__get_IsEmpty(FSharpList__get_Tail(xs))) {\n        return some(FSharpList__get_Head(xs));\n    }\n    else {\n        return void 0;\n    }\n}\nexport function where(predicate, xs) {\n    return filter(predicate, xs);\n}\nexport function pairwise(xs) {\n    return ofArray(pairwise_1(toArray(xs)));\n}\nexport function windowed(windowSize, xs) {\n    return ofArray(map_1(ofArray, windowed_1(windowSize, toArray(xs))));\n}\nexport function splitInto(chunks, xs) {\n    return ofArray(map_1(ofArray, splitInto_1(chunks, toArray(xs))));\n}\nexport function transpose(lists) {\n    return ofArray(map_1(ofArray, transpose_1(map_1(toArray, Array.from(lists)))));\n}\nexport function insertAt(index, y, xs) {\n    let i = -1;\n    let isDone = false;\n    const result = fold((acc, x) => {\n        i = ((i + 1) | 0);\n        if (i === index) {\n            isDone = true;\n            return FSharpList_Cons_305B8EAC(x, FSharpList_Cons_305B8EAC(y, acc));\n        }\n        else {\n            return FSharpList_Cons_305B8EAC(x, acc);\n        }\n    }, FSharpList_get_Empty(), xs);\n    return reverse(isDone ? result : (((i + 1) === index) ? FSharpList_Cons_305B8EAC(y, result) : (() => {\n        throw new Error((SR_indexOutOfBounds + \"\\\\nParameter name: \") + \"index\");\n    })()));\n}\nexport function insertManyAt(index, ys, xs) {\n    let i = -1;\n    let isDone = false;\n    const ys_1 = ofSeq(ys);\n    const result = fold((acc, x) => {\n        i = ((i + 1) | 0);\n        if (i === index) {\n            isDone = true;\n            return FSharpList_Cons_305B8EAC(x, append(ys_1, acc));\n        }\n        else {\n            return FSharpList_Cons_305B8EAC(x, acc);\n        }\n    }, FSharpList_get_Empty(), xs);\n    return reverse(isDone ? result : (((i + 1) === index) ? append(ys_1, result) : (() => {\n        throw new Error((SR_indexOutOfBounds + \"\\\\nParameter name: \") + \"index\");\n    })()));\n}\nexport function removeAt(index, xs) {\n    let i = -1;\n    let isDone = false;\n    const ys = filter((_arg) => {\n        i = ((i + 1) | 0);\n        if (i === index) {\n            isDone = true;\n            return false;\n        }\n        else {\n            return true;\n        }\n    }, xs);\n    if (!isDone) {\n        throw new Error((SR_indexOutOfBounds + \"\\\\nParameter name: \") + \"index\");\n    }\n    return ys;\n}\nexport function removeManyAt(index, count, xs) {\n    let i = -1;\n    let status = -1;\n    const ys = filter((_arg) => {\n        i = ((i + 1) | 0);\n        if (i === index) {\n            status = 0;\n            return false;\n        }\n        else if (i > index) {\n            if (i < (index + count)) {\n                return false;\n            }\n            else {\n                status = 1;\n                return true;\n            }\n        }\n        else {\n            return true;\n        }\n    }, xs);\n    const status_1 = (((status === 0) && ((i + 1) === (index + count))) ? 1 : status) | 0;\n    if (status_1 < 1) {\n        throw new Error((SR_indexOutOfBounds + \"\\\\nParameter name: \") + ((status_1 < 0) ? \"index\" : \"count\"));\n    }\n    return ys;\n}\nexport function updateAt(index, y, xs) {\n    let isDone = false;\n    const ys = mapIndexed((i, x) => {\n        if (i === index) {\n            isDone = true;\n            return y;\n        }\n        else {\n            return x;\n        }\n    }, xs);\n    if (!isDone) {\n        throw new Error((SR_indexOutOfBounds + \"\\\\nParameter name: \") + \"index\");\n    }\n    return ys;\n}\n","import { structuralHash, equals, compare } from \"./Util.js\";\n// Using a class here for better compatibility with TS files importing Some\nexport class Some {\n    constructor(value) {\n        this.value = value;\n    }\n    toJSON() {\n        return this.value;\n    }\n    // Don't add \"Some\" for consistency with erased options\n    toString() {\n        return String(this.value);\n    }\n    GetHashCode() {\n        return structuralHash(this.value);\n    }\n    Equals(other) {\n        if (other == null) {\n            return false;\n        }\n        else {\n            return equals(this.value, other instanceof Some ? other.value : other);\n        }\n    }\n    CompareTo(other) {\n        if (other == null) {\n            return 1;\n        }\n        else {\n            return compare(this.value, other instanceof Some ? other.value : other);\n        }\n    }\n}\nexport function value(x) {\n    if (x == null) {\n        throw new Error(\"Option has no value\");\n    }\n    else {\n        return x instanceof Some ? x.value : x;\n    }\n}\nexport function unwrap(opt) {\n    return opt instanceof Some ? opt.value : opt;\n}\nexport function some(x) {\n    return x == null || x instanceof Some ? new Some(x) : x;\n}\nexport function ofNullable(x) {\n    // This will fail with unit probably, an alternative would be:\n    // return x === null ? undefined : (x === undefined ? new Some(x) : x);\n    return x == null ? undefined : x;\n}\nexport function toNullable(x) {\n    return x == null ? null : value(x);\n}\nexport function flatten(x) {\n    return x == null ? undefined : value(x);\n}\nexport function toArray(opt) {\n    return (opt == null) ? [] : [value(opt)];\n}\nexport function defaultArg(opt, defaultValue) {\n    return (opt != null) ? value(opt) : defaultValue;\n}\nexport function defaultArgWith(opt, defThunk) {\n    return (opt != null) ? value(opt) : defThunk();\n}\nexport function orElse(opt, ifNone) {\n    return opt == null ? ifNone : opt;\n}\nexport function orElseWith(opt, ifNoneThunk) {\n    return opt == null ? ifNoneThunk() : opt;\n}\nexport function filter(predicate, opt) {\n    return (opt != null) ? (predicate(value(opt)) ? opt : undefined) : opt;\n}\nexport function map(mapping, opt) {\n    return (opt != null) ? some(mapping(value(opt))) : undefined;\n}\nexport function map2(mapping, opt1, opt2) {\n    return (opt1 != null && opt2 != null) ? mapping(value(opt1), value(opt2)) : undefined;\n}\nexport function map3(mapping, opt1, opt2, opt3) {\n    return (opt1 != null && opt2 != null && opt3 != null) ? mapping(value(opt1), value(opt2), value(opt3)) : undefined;\n}\nexport function bind(binder, opt) {\n    return opt != null ? binder(value(opt)) : undefined;\n}\nexport function tryOp(op, arg) {\n    try {\n        return some(op(arg));\n    }\n    catch {\n        return undefined;\n    }\n}\n","import { clear, defaultOf, equals, isDisposable, isArrayLike, toIterator, disposeSafe, getEnumerator } from \"./Util.js\";\nimport { toString } from \"./Types.js\";\nimport { class_type } from \"./Reflection.js\";\nimport { some, value as value_1 } from \"./Option.js\";\nimport { Operators_Lock, Operators_NullArg } from \"./FSharp.Core.js\";\nimport { chunkBySize as chunkBySize_1, permute as permute_1, transpose as transpose_1, map as map_1, windowed as windowed_1, splitInto as splitInto_1, pairwise as pairwise_1, scanBack as scanBack_1, reverse as reverse_1, mapFoldBack as mapFoldBack_1, mapFold as mapFold_1, tryItem as tryItem_1, tryHead as tryHead_1, foldBack2 as foldBack2_1, foldBack as foldBack_1, tryFindIndexBack as tryFindIndexBack_1, tryFindBack as tryFindBack_1, singleton as singleton_1 } from \"./Array.js\";\nimport { length as length_1, tryItem as tryItem_2, isEmpty as isEmpty_1, tryHead as tryHead_2, ofSeq as ofSeq_1, ofArray as ofArray_1, toArray as toArray_1, FSharpList } from \"./List.js\";\nimport { SR_indexOutOfBounds } from \"./Global.js\";\nexport const SR_enumerationAlreadyFinished = \"Enumeration already finished.\";\nexport const SR_enumerationNotStarted = \"Enumeration has not started. Call MoveNext.\";\nexport const SR_inputSequenceEmpty = \"The input sequence was empty.\";\nexport const SR_inputSequenceTooLong = \"The input sequence contains more than one element.\";\nexport const SR_keyNotFoundAlt = \"An index satisfying the predicate was not found in the collection.\";\nexport const SR_notEnoughElements = \"The input sequence has an insufficient number of elements.\";\nexport const SR_resetNotSupported = \"Reset is not supported on this enumerator.\";\nexport function Enumerator_noReset() {\n    throw new Error(SR_resetNotSupported);\n}\nexport function Enumerator_notStarted() {\n    throw new Error(SR_enumerationNotStarted);\n}\nexport function Enumerator_alreadyFinished() {\n    throw new Error(SR_enumerationAlreadyFinished);\n}\nexport class Enumerator_Seq {\n    constructor(f) {\n        this.f = f;\n    }\n    toString() {\n        const xs = this;\n        let i = 0;\n        let str = \"seq [\";\n        const e = getEnumerator(xs);\n        try {\n            while ((i < 4) && e[\"System.Collections.IEnumerator.MoveNext\"]()) {\n                if (i > 0) {\n                    str = (str + \"; \");\n                }\n                str = (str + toString(e[\"System.Collections.Generic.IEnumerator`1.get_Current\"]()));\n                i = ((i + 1) | 0);\n            }\n            if (i === 4) {\n                str = (str + \"; ...\");\n            }\n            return str + \"]\";\n        }\n        finally {\n            disposeSafe(e);\n        }\n    }\n    GetEnumerator() {\n        const x = this;\n        return x.f();\n    }\n    [Symbol.iterator]() {\n        return toIterator(getEnumerator(this));\n    }\n    \"System.Collections.IEnumerable.GetEnumerator\"() {\n        const x = this;\n        return x.f();\n    }\n}\nexport function Enumerator_Seq_$reflection(gen0) {\n    return class_type(\"SeqModule.Enumerator.Seq\", [gen0], Enumerator_Seq);\n}\nexport function Enumerator_Seq_$ctor_673A07F2(f) {\n    return new Enumerator_Seq(f);\n}\nexport class Enumerator_FromFunctions$1 {\n    constructor(current, next, dispose) {\n        this.current = current;\n        this.next = next;\n        this.dispose = dispose;\n    }\n    \"System.Collections.Generic.IEnumerator`1.get_Current\"() {\n        const _ = this;\n        return _.current();\n    }\n    \"System.Collections.IEnumerator.get_Current\"() {\n        const _ = this;\n        return _.current();\n    }\n    \"System.Collections.IEnumerator.MoveNext\"() {\n        const _ = this;\n        return _.next();\n    }\n    \"System.Collections.IEnumerator.Reset\"() {\n        Enumerator_noReset();\n    }\n    Dispose() {\n        const _ = this;\n        _.dispose();\n    }\n}\nexport function Enumerator_FromFunctions$1_$reflection(gen0) {\n    return class_type(\"SeqModule.Enumerator.FromFunctions`1\", [gen0], Enumerator_FromFunctions$1);\n}\nexport function Enumerator_FromFunctions$1_$ctor_58C54629(current, next, dispose) {\n    return new Enumerator_FromFunctions$1(current, next, dispose);\n}\nexport function Enumerator_cast(e) {\n    return Enumerator_FromFunctions$1_$ctor_58C54629(() => e[\"System.Collections.Generic.IEnumerator`1.get_Current\"](), () => e[\"System.Collections.IEnumerator.MoveNext\"](), () => {\n        const e_1 = e;\n        disposeSafe(e_1);\n    });\n}\nexport function Enumerator_concat(sources) {\n    let outerOpt = void 0;\n    let innerOpt = void 0;\n    let started = false;\n    let finished = false;\n    let curr = void 0;\n    const finish = () => {\n        finished = true;\n        if (innerOpt != null) {\n            const inner = value_1(innerOpt);\n            try {\n                disposeSafe(inner);\n            }\n            finally {\n                innerOpt = void 0;\n            }\n        }\n        if (outerOpt != null) {\n            const outer = value_1(outerOpt);\n            try {\n                disposeSafe(outer);\n            }\n            finally {\n                outerOpt = void 0;\n            }\n        }\n    };\n    return Enumerator_FromFunctions$1_$ctor_58C54629(() => {\n        if (!started) {\n            Enumerator_notStarted();\n        }\n        else if (finished) {\n            Enumerator_alreadyFinished();\n        }\n        if (curr != null) {\n            return value_1(curr);\n        }\n        else {\n            return Enumerator_alreadyFinished();\n        }\n    }, () => {\n        let copyOfStruct;\n        if (!started) {\n            started = true;\n        }\n        if (finished) {\n            return false;\n        }\n        else {\n            let res = void 0;\n            while (res == null) {\n                const outerOpt_1 = outerOpt;\n                const innerOpt_1 = innerOpt;\n                if (outerOpt_1 != null) {\n                    if (innerOpt_1 != null) {\n                        const inner_1 = value_1(innerOpt_1);\n                        if (inner_1[\"System.Collections.IEnumerator.MoveNext\"]()) {\n                            curr = some(inner_1[\"System.Collections.Generic.IEnumerator`1.get_Current\"]());\n                            res = true;\n                        }\n                        else {\n                            try {\n                                disposeSafe(inner_1);\n                            }\n                            finally {\n                                innerOpt = void 0;\n                            }\n                        }\n                    }\n                    else {\n                        const outer_1 = value_1(outerOpt_1);\n                        if (outer_1[\"System.Collections.IEnumerator.MoveNext\"]()) {\n                            const ie = outer_1[\"System.Collections.Generic.IEnumerator`1.get_Current\"]();\n                            innerOpt = ((copyOfStruct = ie, getEnumerator(copyOfStruct)));\n                        }\n                        else {\n                            finish();\n                            res = false;\n                        }\n                    }\n                }\n                else {\n                    outerOpt = getEnumerator(sources);\n                }\n            }\n            return value_1(res);\n        }\n    }, () => {\n        if (!finished) {\n            finish();\n        }\n    });\n}\nexport function Enumerator_enumerateThenFinally(f, e) {\n    return Enumerator_FromFunctions$1_$ctor_58C54629(() => e[\"System.Collections.Generic.IEnumerator`1.get_Current\"](), () => e[\"System.Collections.IEnumerator.MoveNext\"](), () => {\n        try {\n            disposeSafe(e);\n        }\n        finally {\n            f();\n        }\n    });\n}\nexport function Enumerator_generateWhileSome(openf, compute, closef) {\n    let started = false;\n    let curr = void 0;\n    let state = some(openf());\n    const dispose = () => {\n        if (state != null) {\n            const x_1 = value_1(state);\n            try {\n                closef(x_1);\n            }\n            finally {\n                state = void 0;\n            }\n        }\n    };\n    const finish = () => {\n        try {\n            dispose();\n        }\n        finally {\n            curr = void 0;\n        }\n    };\n    return Enumerator_FromFunctions$1_$ctor_58C54629(() => {\n        if (!started) {\n            Enumerator_notStarted();\n        }\n        if (curr != null) {\n            return value_1(curr);\n        }\n        else {\n            return Enumerator_alreadyFinished();\n        }\n    }, () => {\n        if (!started) {\n            started = true;\n        }\n        if (state != null) {\n            const s = value_1(state);\n            let matchValue_1;\n            try {\n                matchValue_1 = compute(s);\n            }\n            catch (matchValue) {\n                finish();\n                throw matchValue;\n            }\n            if (matchValue_1 != null) {\n                curr = matchValue_1;\n                return true;\n            }\n            else {\n                finish();\n                return false;\n            }\n        }\n        else {\n            return false;\n        }\n    }, dispose);\n}\nexport function Enumerator_unfold(f, state) {\n    let curr = void 0;\n    let acc = state;\n    return Enumerator_FromFunctions$1_$ctor_58C54629(() => {\n        if (curr != null) {\n            const x = value_1(curr)[0];\n            const st = value_1(curr)[1];\n            return x;\n        }\n        else {\n            return Enumerator_notStarted();\n        }\n    }, () => {\n        curr = f(acc);\n        if (curr != null) {\n            const x_1 = value_1(curr)[0];\n            const st_1 = value_1(curr)[1];\n            acc = st_1;\n            return true;\n        }\n        else {\n            return false;\n        }\n    }, () => {\n    });\n}\nexport function indexNotFound() {\n    throw new Error(SR_keyNotFoundAlt);\n}\nexport function checkNonNull(argName, arg) {\n    if (arg == null) {\n        Operators_NullArg(argName);\n    }\n}\nexport function mkSeq(f) {\n    return Enumerator_Seq_$ctor_673A07F2(f);\n}\nexport function ofSeq(xs) {\n    checkNonNull(\"source\", xs);\n    return getEnumerator(xs);\n}\nexport function delay(generator) {\n    return mkSeq(() => getEnumerator(generator()));\n}\nexport function concat(sources) {\n    return mkSeq(() => Enumerator_concat(sources));\n}\nexport function unfold(generator, state) {\n    return mkSeq(() => Enumerator_unfold(generator, state));\n}\nexport function empty() {\n    return delay(() => (new Array(0)));\n}\nexport function singleton(x) {\n    return delay(() => singleton_1(x));\n}\nexport function ofArray(arr) {\n    return arr;\n}\nexport function toArray(xs) {\n    if (xs instanceof FSharpList) {\n        const a = xs;\n        return toArray_1(a);\n    }\n    else {\n        return Array.from(xs);\n    }\n}\nexport function ofList(xs) {\n    return xs;\n}\nexport function toList(xs) {\n    if (isArrayLike(xs)) {\n        return ofArray_1(xs);\n    }\n    else if (xs instanceof FSharpList) {\n        return xs;\n    }\n    else {\n        return ofSeq_1(xs);\n    }\n}\nexport function generate(create, compute, dispose) {\n    return mkSeq(() => Enumerator_generateWhileSome(create, compute, dispose));\n}\nexport function generateIndexed(create, compute, dispose) {\n    return mkSeq(() => {\n        let i = -1;\n        return Enumerator_generateWhileSome(create, (x) => {\n            i = ((i + 1) | 0);\n            return compute(i, x);\n        }, dispose);\n    });\n}\nexport function append(xs, ys) {\n    return concat([xs, ys]);\n}\nexport function cast(xs) {\n    return mkSeq(() => {\n        checkNonNull(\"source\", xs);\n        return Enumerator_cast(getEnumerator(xs));\n    });\n}\nexport function choose(chooser, xs) {\n    return generate(() => ofSeq(xs), (e) => {\n        let curr = void 0;\n        while ((curr == null) && e[\"System.Collections.IEnumerator.MoveNext\"]()) {\n            curr = chooser(e[\"System.Collections.Generic.IEnumerator`1.get_Current\"]());\n        }\n        return curr;\n    }, (e_1) => {\n        disposeSafe(e_1);\n    });\n}\nexport function compareWith(comparer, xs, ys) {\n    const e1 = ofSeq(xs);\n    try {\n        const e2 = ofSeq(ys);\n        try {\n            let c = 0;\n            let b1 = e1[\"System.Collections.IEnumerator.MoveNext\"]();\n            let b2 = e2[\"System.Collections.IEnumerator.MoveNext\"]();\n            while (((c === 0) && b1) && b2) {\n                c = (comparer(e1[\"System.Collections.Generic.IEnumerator`1.get_Current\"](), e2[\"System.Collections.Generic.IEnumerator`1.get_Current\"]()) | 0);\n                if (c === 0) {\n                    b1 = e1[\"System.Collections.IEnumerator.MoveNext\"]();\n                    b2 = e2[\"System.Collections.IEnumerator.MoveNext\"]();\n                }\n            }\n            return ((c !== 0) ? c : (b1 ? 1 : (b2 ? -1 : 0))) | 0;\n        }\n        finally {\n            disposeSafe(e2);\n        }\n    }\n    finally {\n        disposeSafe(e1);\n    }\n}\nexport function contains(value, xs, comparer) {\n    const e = ofSeq(xs);\n    try {\n        let found = false;\n        while (!found && e[\"System.Collections.IEnumerator.MoveNext\"]()) {\n            found = comparer.Equals(value, e[\"System.Collections.Generic.IEnumerator`1.get_Current\"]());\n        }\n        return found;\n    }\n    finally {\n        disposeSafe(e);\n    }\n}\nexport function enumerateFromFunctions(create, moveNext, current) {\n    return generate(create, (x) => (moveNext(x) ? some(current(x)) : void 0), (x_1) => {\n        const matchValue = x_1;\n        if (isDisposable(matchValue)) {\n            const id = matchValue;\n            disposeSafe(id);\n        }\n    });\n}\nexport function enumerateThenFinally(source, compensation) {\n    const compensation_1 = compensation;\n    return mkSeq(() => {\n        try {\n            return Enumerator_enumerateThenFinally(compensation_1, ofSeq(source));\n        }\n        catch (matchValue) {\n            compensation_1();\n            throw matchValue;\n        }\n    });\n}\nexport function enumerateUsing(resource, source) {\n    const compensation = () => {\n        if (equals(resource, defaultOf())) {\n        }\n        else {\n            let copyOfStruct = resource;\n            disposeSafe(copyOfStruct);\n        }\n    };\n    return mkSeq(() => {\n        try {\n            return Enumerator_enumerateThenFinally(compensation, ofSeq(source(resource)));\n        }\n        catch (matchValue_1) {\n            compensation();\n            throw matchValue_1;\n        }\n    });\n}\nexport function enumerateWhile(guard, xs) {\n    return concat(unfold((i) => (guard() ? [xs, i + 1] : void 0), 0));\n}\nexport function filter(f, xs) {\n    return choose((x) => {\n        if (f(x)) {\n            return some(x);\n        }\n        else {\n            return void 0;\n        }\n    }, xs);\n}\nexport function exists(predicate, xs) {\n    const e = ofSeq(xs);\n    try {\n        let found = false;\n        while (!found && e[\"System.Collections.IEnumerator.MoveNext\"]()) {\n            found = predicate(e[\"System.Collections.Generic.IEnumerator`1.get_Current\"]());\n        }\n        return found;\n    }\n    finally {\n        disposeSafe(e);\n    }\n}\nexport function exists2(predicate, xs, ys) {\n    const e1 = ofSeq(xs);\n    try {\n        const e2 = ofSeq(ys);\n        try {\n            let found = false;\n            while ((!found && e1[\"System.Collections.IEnumerator.MoveNext\"]()) && e2[\"System.Collections.IEnumerator.MoveNext\"]()) {\n                found = predicate(e1[\"System.Collections.Generic.IEnumerator`1.get_Current\"](), e2[\"System.Collections.Generic.IEnumerator`1.get_Current\"]());\n            }\n            return found;\n        }\n        finally {\n            disposeSafe(e2);\n        }\n    }\n    finally {\n        disposeSafe(e1);\n    }\n}\nexport function exactlyOne(xs) {\n    const e = ofSeq(xs);\n    try {\n        if (e[\"System.Collections.IEnumerator.MoveNext\"]()) {\n            const v = e[\"System.Collections.Generic.IEnumerator`1.get_Current\"]();\n            if (e[\"System.Collections.IEnumerator.MoveNext\"]()) {\n                throw new Error((SR_inputSequenceTooLong + \"\\\\nParameter name: \") + \"source\");\n            }\n            else {\n                return v;\n            }\n        }\n        else {\n            throw new Error((SR_inputSequenceEmpty + \"\\\\nParameter name: \") + \"source\");\n        }\n    }\n    finally {\n        disposeSafe(e);\n    }\n}\nexport function tryExactlyOne(xs) {\n    const e = ofSeq(xs);\n    try {\n        if (e[\"System.Collections.IEnumerator.MoveNext\"]()) {\n            const v = e[\"System.Collections.Generic.IEnumerator`1.get_Current\"]();\n            return e[\"System.Collections.IEnumerator.MoveNext\"]() ? void 0 : some(v);\n        }\n        else {\n            return void 0;\n        }\n    }\n    finally {\n        disposeSafe(e);\n    }\n}\nexport function tryFind(predicate, xs) {\n    const e = ofSeq(xs);\n    try {\n        let res = void 0;\n        while ((res == null) && e[\"System.Collections.IEnumerator.MoveNext\"]()) {\n            const c = e[\"System.Collections.Generic.IEnumerator`1.get_Current\"]();\n            if (predicate(c)) {\n                res = some(c);\n            }\n        }\n        return res;\n    }\n    finally {\n        disposeSafe(e);\n    }\n}\nexport function find(predicate, xs) {\n    const matchValue = tryFind(predicate, xs);\n    if (matchValue == null) {\n        return indexNotFound();\n    }\n    else {\n        return value_1(matchValue);\n    }\n}\nexport function tryFindBack(predicate, xs) {\n    return tryFindBack_1(predicate, toArray(xs));\n}\nexport function findBack(predicate, xs) {\n    const matchValue = tryFindBack(predicate, xs);\n    if (matchValue == null) {\n        return indexNotFound();\n    }\n    else {\n        return value_1(matchValue);\n    }\n}\nexport function tryFindIndex(predicate, xs) {\n    const e = ofSeq(xs);\n    try {\n        const loop = (i_mut) => {\n            loop: while (true) {\n                const i = i_mut;\n                if (e[\"System.Collections.IEnumerator.MoveNext\"]()) {\n                    if (predicate(e[\"System.Collections.Generic.IEnumerator`1.get_Current\"]())) {\n                        return i;\n                    }\n                    else {\n                        i_mut = (i + 1);\n                        continue loop;\n                    }\n                }\n                else {\n                    return void 0;\n                }\n                break;\n            }\n        };\n        return loop(0);\n    }\n    finally {\n        disposeSafe(e);\n    }\n}\nexport function findIndex(predicate, xs) {\n    const matchValue = tryFindIndex(predicate, xs);\n    if (matchValue == null) {\n        indexNotFound();\n        return -1;\n    }\n    else {\n        return value_1(matchValue) | 0;\n    }\n}\nexport function tryFindIndexBack(predicate, xs) {\n    return tryFindIndexBack_1(predicate, toArray(xs));\n}\nexport function findIndexBack(predicate, xs) {\n    const matchValue = tryFindIndexBack(predicate, xs);\n    if (matchValue == null) {\n        indexNotFound();\n        return -1;\n    }\n    else {\n        return value_1(matchValue) | 0;\n    }\n}\nexport function fold(folder, state, xs) {\n    const e = ofSeq(xs);\n    try {\n        let acc = state;\n        while (e[\"System.Collections.IEnumerator.MoveNext\"]()) {\n            acc = folder(acc, e[\"System.Collections.Generic.IEnumerator`1.get_Current\"]());\n        }\n        return acc;\n    }\n    finally {\n        disposeSafe(e);\n    }\n}\nexport function foldBack(folder, xs, state) {\n    return foldBack_1(folder, toArray(xs), state);\n}\nexport function fold2(folder, state, xs, ys) {\n    const e1 = ofSeq(xs);\n    try {\n        const e2 = ofSeq(ys);\n        try {\n            let acc = state;\n            while (e1[\"System.Collections.IEnumerator.MoveNext\"]() && e2[\"System.Collections.IEnumerator.MoveNext\"]()) {\n                acc = folder(acc, e1[\"System.Collections.Generic.IEnumerator`1.get_Current\"](), e2[\"System.Collections.Generic.IEnumerator`1.get_Current\"]());\n            }\n            return acc;\n        }\n        finally {\n            disposeSafe(e2);\n        }\n    }\n    finally {\n        disposeSafe(e1);\n    }\n}\nexport function foldBack2(folder, xs, ys, state) {\n    return foldBack2_1(folder, toArray(xs), toArray(ys), state);\n}\nexport function forAll(predicate, xs) {\n    return !exists((x) => !predicate(x), xs);\n}\nexport function forAll2(predicate, xs, ys) {\n    return !exists2((x, y) => !predicate(x, y), xs, ys);\n}\nexport function tryHead(xs) {\n    if (isArrayLike(xs)) {\n        return tryHead_1(xs);\n    }\n    else if (xs instanceof FSharpList) {\n        return tryHead_2(xs);\n    }\n    else {\n        const e = ofSeq(xs);\n        try {\n            return e[\"System.Collections.IEnumerator.MoveNext\"]() ? some(e[\"System.Collections.Generic.IEnumerator`1.get_Current\"]()) : void 0;\n        }\n        finally {\n            disposeSafe(e);\n        }\n    }\n}\nexport function head(xs) {\n    const matchValue = tryHead(xs);\n    if (matchValue == null) {\n        throw new Error((SR_inputSequenceEmpty + \"\\\\nParameter name: \") + \"source\");\n    }\n    else {\n        return value_1(matchValue);\n    }\n}\nexport function initialize(count, f) {\n    return unfold((i) => ((i < count) ? [f(i), i + 1] : void 0), 0);\n}\nexport function initializeInfinite(f) {\n    return initialize(2147483647, f);\n}\nexport function isEmpty(xs) {\n    if (isArrayLike(xs)) {\n        const a = xs;\n        return a.length === 0;\n    }\n    else if (xs instanceof FSharpList) {\n        return isEmpty_1(xs);\n    }\n    else {\n        const e = ofSeq(xs);\n        try {\n            return !e[\"System.Collections.IEnumerator.MoveNext\"]();\n        }\n        finally {\n            disposeSafe(e);\n        }\n    }\n}\nexport function tryItem(index, xs) {\n    if (isArrayLike(xs)) {\n        return tryItem_1(index, xs);\n    }\n    else if (xs instanceof FSharpList) {\n        return tryItem_2(index, xs);\n    }\n    else {\n        const e = ofSeq(xs);\n        try {\n            const loop = (index_1_mut) => {\n                loop: while (true) {\n                    const index_1 = index_1_mut;\n                    if (!e[\"System.Collections.IEnumerator.MoveNext\"]()) {\n                        return void 0;\n                    }\n                    else if (index_1 === 0) {\n                        return some(e[\"System.Collections.Generic.IEnumerator`1.get_Current\"]());\n                    }\n                    else {\n                        index_1_mut = (index_1 - 1);\n                        continue loop;\n                    }\n                    break;\n                }\n            };\n            return loop(index);\n        }\n        finally {\n            disposeSafe(e);\n        }\n    }\n}\nexport function item(index, xs) {\n    const matchValue = tryItem(index, xs);\n    if (matchValue == null) {\n        throw new Error((SR_notEnoughElements + \"\\\\nParameter name: \") + \"index\");\n    }\n    else {\n        return value_1(matchValue);\n    }\n}\nexport function iterate(action, xs) {\n    fold((unitVar, x) => {\n        action(x);\n    }, void 0, xs);\n}\nexport function iterate2(action, xs, ys) {\n    fold2((unitVar, x, y) => {\n        action(x, y);\n    }, void 0, xs, ys);\n}\nexport function iterateIndexed(action, xs) {\n    fold((i, x) => {\n        action(i, x);\n        return (i + 1) | 0;\n    }, 0, xs);\n}\nexport function iterateIndexed2(action, xs, ys) {\n    fold2((i, x, y) => {\n        action(i, x, y);\n        return (i + 1) | 0;\n    }, 0, xs, ys);\n}\nexport function tryLast(xs) {\n    const e = ofSeq(xs);\n    try {\n        const loop = (acc_mut) => {\n            loop: while (true) {\n                const acc = acc_mut;\n                if (!e[\"System.Collections.IEnumerator.MoveNext\"]()) {\n                    return acc;\n                }\n                else {\n                    acc_mut = e[\"System.Collections.Generic.IEnumerator`1.get_Current\"]();\n                    continue loop;\n                }\n                break;\n            }\n        };\n        return e[\"System.Collections.IEnumerator.MoveNext\"]() ? some(loop(e[\"System.Collections.Generic.IEnumerator`1.get_Current\"]())) : void 0;\n    }\n    finally {\n        disposeSafe(e);\n    }\n}\nexport function last(xs) {\n    const matchValue = tryLast(xs);\n    if (matchValue == null) {\n        throw new Error((SR_notEnoughElements + \"\\\\nParameter name: \") + \"source\");\n    }\n    else {\n        return value_1(matchValue);\n    }\n}\nexport function length(xs) {\n    if (isArrayLike(xs)) {\n        const a = xs;\n        return a.length | 0;\n    }\n    else if (xs instanceof FSharpList) {\n        return length_1(xs) | 0;\n    }\n    else {\n        const e = ofSeq(xs);\n        try {\n            let count = 0;\n            while (e[\"System.Collections.IEnumerator.MoveNext\"]()) {\n                count = ((count + 1) | 0);\n            }\n            return count | 0;\n        }\n        finally {\n            disposeSafe(e);\n        }\n    }\n}\nexport function map(mapping, xs) {\n    return generate(() => ofSeq(xs), (e) => (e[\"System.Collections.IEnumerator.MoveNext\"]() ? some(mapping(e[\"System.Collections.Generic.IEnumerator`1.get_Current\"]())) : void 0), (e_1) => {\n        disposeSafe(e_1);\n    });\n}\nexport function mapIndexed(mapping, xs) {\n    return generateIndexed(() => ofSeq(xs), (i, e) => (e[\"System.Collections.IEnumerator.MoveNext\"]() ? some(mapping(i, e[\"System.Collections.Generic.IEnumerator`1.get_Current\"]())) : void 0), (e_1) => {\n        disposeSafe(e_1);\n    });\n}\nexport function indexed(xs) {\n    return mapIndexed((i, x) => [i, x], xs);\n}\nexport function map2(mapping, xs, ys) {\n    return generate(() => [ofSeq(xs), ofSeq(ys)], (tupledArg) => {\n        const e1 = tupledArg[0];\n        const e2 = tupledArg[1];\n        return (e1[\"System.Collections.IEnumerator.MoveNext\"]() && e2[\"System.Collections.IEnumerator.MoveNext\"]()) ? some(mapping(e1[\"System.Collections.Generic.IEnumerator`1.get_Current\"](), e2[\"System.Collections.Generic.IEnumerator`1.get_Current\"]())) : void 0;\n    }, (tupledArg_1) => {\n        try {\n            disposeSafe(tupledArg_1[0]);\n        }\n        finally {\n            disposeSafe(tupledArg_1[1]);\n        }\n    });\n}\nexport function mapIndexed2(mapping, xs, ys) {\n    return generateIndexed(() => [ofSeq(xs), ofSeq(ys)], (i, tupledArg) => {\n        const e1 = tupledArg[0];\n        const e2 = tupledArg[1];\n        return (e1[\"System.Collections.IEnumerator.MoveNext\"]() && e2[\"System.Collections.IEnumerator.MoveNext\"]()) ? some(mapping(i, e1[\"System.Collections.Generic.IEnumerator`1.get_Current\"](), e2[\"System.Collections.Generic.IEnumerator`1.get_Current\"]())) : void 0;\n    }, (tupledArg_1) => {\n        try {\n            disposeSafe(tupledArg_1[0]);\n        }\n        finally {\n            disposeSafe(tupledArg_1[1]);\n        }\n    });\n}\nexport function map3(mapping, xs, ys, zs) {\n    return generate(() => [ofSeq(xs), ofSeq(ys), ofSeq(zs)], (tupledArg) => {\n        const e1 = tupledArg[0];\n        const e2 = tupledArg[1];\n        const e3 = tupledArg[2];\n        return ((e1[\"System.Collections.IEnumerator.MoveNext\"]() && e2[\"System.Collections.IEnumerator.MoveNext\"]()) && e3[\"System.Collections.IEnumerator.MoveNext\"]()) ? some(mapping(e1[\"System.Collections.Generic.IEnumerator`1.get_Current\"](), e2[\"System.Collections.Generic.IEnumerator`1.get_Current\"](), e3[\"System.Collections.Generic.IEnumerator`1.get_Current\"]())) : void 0;\n    }, (tupledArg_1) => {\n        try {\n            disposeSafe(tupledArg_1[0]);\n        }\n        finally {\n            try {\n                disposeSafe(tupledArg_1[1]);\n            }\n            finally {\n                disposeSafe(tupledArg_1[2]);\n            }\n        }\n    });\n}\nexport function readOnly(xs) {\n    checkNonNull(\"source\", xs);\n    return map((x) => x, xs);\n}\nexport class CachedSeq$1 {\n    constructor(cleanup, res) {\n        this.cleanup = cleanup;\n        this.res = res;\n    }\n    Dispose() {\n        const _ = this;\n        _.cleanup();\n    }\n    GetEnumerator() {\n        const _ = this;\n        return getEnumerator(_.res);\n    }\n    [Symbol.iterator]() {\n        return toIterator(getEnumerator(this));\n    }\n    \"System.Collections.IEnumerable.GetEnumerator\"() {\n        const _ = this;\n        return getEnumerator(_.res);\n    }\n}\nexport function CachedSeq$1_$reflection(gen0) {\n    return class_type(\"SeqModule.CachedSeq`1\", [gen0], CachedSeq$1);\n}\nexport function CachedSeq$1_$ctor_Z7A8347D4(cleanup, res) {\n    return new CachedSeq$1(cleanup, res);\n}\nexport function CachedSeq$1__Clear(_) {\n    _.cleanup();\n}\nexport function cache(source) {\n    checkNonNull(\"source\", source);\n    const prefix = [];\n    let enumeratorR = void 0;\n    return CachedSeq$1_$ctor_Z7A8347D4(() => {\n        Operators_Lock(prefix, () => {\n            clear(prefix);\n            let matchResult, e;\n            if (enumeratorR != null) {\n                if (value_1(enumeratorR) != null) {\n                    matchResult = 0;\n                    e = value_1(value_1(enumeratorR));\n                }\n                else {\n                    matchResult = 1;\n                }\n            }\n            else {\n                matchResult = 1;\n            }\n            switch (matchResult) {\n                case 0: {\n                    disposeSafe(e);\n                    break;\n                }\n            }\n            enumeratorR = void 0;\n        });\n    }, unfold((i_1) => Operators_Lock(prefix, () => {\n        if (i_1 < prefix.length) {\n            return [prefix[i_1], i_1 + 1];\n        }\n        else {\n            if (i_1 >= prefix.length) {\n                let optEnumerator_2;\n                if (enumeratorR != null) {\n                    optEnumerator_2 = value_1(enumeratorR);\n                }\n                else {\n                    const optEnumerator = getEnumerator(source);\n                    enumeratorR = some(optEnumerator);\n                    optEnumerator_2 = optEnumerator;\n                }\n                if (optEnumerator_2 == null) {\n                }\n                else {\n                    const enumerator = value_1(optEnumerator_2);\n                    if (enumerator[\"System.Collections.IEnumerator.MoveNext\"]()) {\n                        void (prefix.push(enumerator[\"System.Collections.Generic.IEnumerator`1.get_Current\"]()));\n                    }\n                    else {\n                        disposeSafe(enumerator);\n                        enumeratorR = some(void 0);\n                    }\n                }\n            }\n            if (i_1 < prefix.length) {\n                return [prefix[i_1], i_1 + 1];\n            }\n            else {\n                return void 0;\n            }\n        }\n    }), 0));\n}\nexport function allPairs(xs, ys) {\n    const ysCache = cache(ys);\n    return delay(() => concat(map((x) => map((y) => [x, y], ysCache), xs)));\n}\nexport function mapFold(mapping, state, xs) {\n    const patternInput = mapFold_1(mapping, state, toArray(xs));\n    return [readOnly(patternInput[0]), patternInput[1]];\n}\nexport function mapFoldBack(mapping, xs, state) {\n    const patternInput = mapFoldBack_1(mapping, toArray(xs), state);\n    return [readOnly(patternInput[0]), patternInput[1]];\n}\nexport function tryPick(chooser, xs) {\n    const e = ofSeq(xs);\n    try {\n        let res = void 0;\n        while ((res == null) && e[\"System.Collections.IEnumerator.MoveNext\"]()) {\n            res = chooser(e[\"System.Collections.Generic.IEnumerator`1.get_Current\"]());\n        }\n        return res;\n    }\n    finally {\n        disposeSafe(e);\n    }\n}\nexport function pick(chooser, xs) {\n    const matchValue = tryPick(chooser, xs);\n    if (matchValue == null) {\n        return indexNotFound();\n    }\n    else {\n        return value_1(matchValue);\n    }\n}\nexport function reduce(folder, xs) {\n    const e = ofSeq(xs);\n    try {\n        const loop = (acc_mut) => {\n            loop: while (true) {\n                const acc = acc_mut;\n                if (e[\"System.Collections.IEnumerator.MoveNext\"]()) {\n                    acc_mut = folder(acc, e[\"System.Collections.Generic.IEnumerator`1.get_Current\"]());\n                    continue loop;\n                }\n                else {\n                    return acc;\n                }\n                break;\n            }\n        };\n        if (e[\"System.Collections.IEnumerator.MoveNext\"]()) {\n            return loop(e[\"System.Collections.Generic.IEnumerator`1.get_Current\"]());\n        }\n        else {\n            throw new Error(SR_inputSequenceEmpty);\n        }\n    }\n    finally {\n        disposeSafe(e);\n    }\n}\nexport function reduceBack(folder, xs) {\n    const arr = toArray(xs);\n    if (arr.length > 0) {\n        return arr.reduceRight(folder);\n    }\n    else {\n        throw new Error(SR_inputSequenceEmpty);\n    }\n}\nexport function replicate(n, x) {\n    return initialize(n, (_arg) => x);\n}\nexport function reverse(xs) {\n    return delay(() => ofArray(reverse_1(toArray(xs))));\n}\nexport function scan(folder, state, xs) {\n    return delay(() => {\n        let acc = state;\n        return concat([singleton(state), map((x) => {\n                acc = folder(acc, x);\n                return acc;\n            }, xs)]);\n    });\n}\nexport function scanBack(folder, xs, state) {\n    return delay(() => ofArray(scanBack_1(folder, toArray(xs), state)));\n}\nexport function skip(count, source) {\n    return mkSeq(() => {\n        const e = ofSeq(source);\n        try {\n            for (let _ = 1; _ <= count; _++) {\n                if (!e[\"System.Collections.IEnumerator.MoveNext\"]()) {\n                    throw new Error((SR_notEnoughElements + \"\\\\nParameter name: \") + \"source\");\n                }\n            }\n            return Enumerator_enumerateThenFinally(() => {\n            }, e);\n        }\n        catch (matchValue) {\n            disposeSafe(e);\n            throw matchValue;\n        }\n    });\n}\nexport function skipWhile(predicate, xs) {\n    return delay(() => {\n        let skipped = true;\n        return filter((x) => {\n            if (skipped) {\n                skipped = predicate(x);\n            }\n            return !skipped;\n        }, xs);\n    });\n}\nexport function tail(xs) {\n    return skip(1, xs);\n}\nexport function take(count, xs) {\n    return generateIndexed(() => ofSeq(xs), (i, e) => {\n        if (i < count) {\n            if (e[\"System.Collections.IEnumerator.MoveNext\"]()) {\n                return some(e[\"System.Collections.Generic.IEnumerator`1.get_Current\"]());\n            }\n            else {\n                throw new Error((SR_notEnoughElements + \"\\\\nParameter name: \") + \"source\");\n            }\n        }\n        else {\n            return void 0;\n        }\n    }, (e_1) => {\n        disposeSafe(e_1);\n    });\n}\nexport function takeWhile(predicate, xs) {\n    return generate(() => ofSeq(xs), (e) => ((e[\"System.Collections.IEnumerator.MoveNext\"]() && predicate(e[\"System.Collections.Generic.IEnumerator`1.get_Current\"]())) ? some(e[\"System.Collections.Generic.IEnumerator`1.get_Current\"]()) : void 0), (e_1) => {\n        disposeSafe(e_1);\n    });\n}\nexport function truncate(count, xs) {\n    return generateIndexed(() => ofSeq(xs), (i, e) => (((i < count) && e[\"System.Collections.IEnumerator.MoveNext\"]()) ? some(e[\"System.Collections.Generic.IEnumerator`1.get_Current\"]()) : void 0), (e_1) => {\n        disposeSafe(e_1);\n    });\n}\nexport function zip(xs, ys) {\n    return map2((x, y) => [x, y], xs, ys);\n}\nexport function zip3(xs, ys, zs) {\n    return map3((x, y, z) => [x, y, z], xs, ys, zs);\n}\nexport function collect(mapping, xs) {\n    return delay(() => concat(map(mapping, xs)));\n}\nexport function where(predicate, xs) {\n    return filter(predicate, xs);\n}\nexport function pairwise(xs) {\n    return delay(() => ofArray(pairwise_1(toArray(xs))));\n}\nexport function splitInto(chunks, xs) {\n    return delay(() => ofArray(splitInto_1(chunks, toArray(xs))));\n}\nexport function windowed(windowSize, xs) {\n    return delay(() => ofArray(windowed_1(windowSize, toArray(xs))));\n}\nexport function transpose(xss) {\n    return delay(() => ofArray(map_1(ofArray, transpose_1(map_1(toArray, toArray(xss))))));\n}\nexport function sortWith(comparer, xs) {\n    return delay(() => {\n        const arr = toArray(xs);\n        arr.sort(comparer);\n        return ofArray(arr);\n    });\n}\nexport function sort(xs, comparer) {\n    return sortWith((x, y) => comparer.Compare(x, y), xs);\n}\nexport function sortBy(projection, xs, comparer) {\n    return sortWith((x, y) => comparer.Compare(projection(x), projection(y)), xs);\n}\nexport function sortDescending(xs, comparer) {\n    return sortWith((x, y) => (comparer.Compare(x, y) * -1), xs);\n}\nexport function sortByDescending(projection, xs, comparer) {\n    return sortWith((x, y) => (comparer.Compare(projection(x), projection(y)) * -1), xs);\n}\nexport function sum(xs, adder) {\n    return fold((acc, x) => adder.Add(acc, x), adder.GetZero(), xs);\n}\nexport function sumBy(f, xs, adder) {\n    return fold((acc, x) => adder.Add(acc, f(x)), adder.GetZero(), xs);\n}\nexport function maxBy(projection, xs, comparer) {\n    return reduce((x, y) => ((comparer.Compare(projection(y), projection(x)) > 0) ? y : x), xs);\n}\nexport function max(xs, comparer) {\n    return reduce((x, y) => ((comparer.Compare(y, x) > 0) ? y : x), xs);\n}\nexport function minBy(projection, xs, comparer) {\n    return reduce((x, y) => ((comparer.Compare(projection(y), projection(x)) > 0) ? x : y), xs);\n}\nexport function min(xs, comparer) {\n    return reduce((x, y) => ((comparer.Compare(y, x) > 0) ? x : y), xs);\n}\nexport function average(xs, averager) {\n    let count = 0;\n    const total = fold((acc, x) => {\n        count = ((count + 1) | 0);\n        return averager.Add(acc, x);\n    }, averager.GetZero(), xs);\n    if (count === 0) {\n        throw new Error((SR_inputSequenceEmpty + \"\\\\nParameter name: \") + \"source\");\n    }\n    else {\n        return averager.DivideByInt(total, count);\n    }\n}\nexport function averageBy(f, xs, averager) {\n    let count = 0;\n    const total = fold((acc, x) => {\n        count = ((count + 1) | 0);\n        return averager.Add(acc, f(x));\n    }, averager.GetZero(), xs);\n    if (count === 0) {\n        throw new Error((SR_inputSequenceEmpty + \"\\\\nParameter name: \") + \"source\");\n    }\n    else {\n        return averager.DivideByInt(total, count);\n    }\n}\nexport function permute(f, xs) {\n    return delay(() => ofArray(permute_1(f, toArray(xs))));\n}\nexport function chunkBySize(chunkSize, xs) {\n    return delay(() => ofArray(chunkBySize_1(chunkSize, toArray(xs))));\n}\nexport function insertAt(index, y, xs) {\n    let isDone = false;\n    if (index < 0) {\n        throw new Error((SR_indexOutOfBounds + \"\\\\nParameter name: \") + \"index\");\n    }\n    return generateIndexed(() => ofSeq(xs), (i, e) => {\n        if ((isDone ? true : (i < index)) && e[\"System.Collections.IEnumerator.MoveNext\"]()) {\n            return some(e[\"System.Collections.Generic.IEnumerator`1.get_Current\"]());\n        }\n        else if (i === index) {\n            isDone = true;\n            return some(y);\n        }\n        else {\n            if (!isDone) {\n                throw new Error((SR_indexOutOfBounds + \"\\\\nParameter name: \") + \"index\");\n            }\n            return void 0;\n        }\n    }, (e_1) => {\n        disposeSafe(e_1);\n    });\n}\nexport function insertManyAt(index, ys, xs) {\n    let status = -1;\n    if (index < 0) {\n        throw new Error((SR_indexOutOfBounds + \"\\\\nParameter name: \") + \"index\");\n    }\n    return generateIndexed(() => [ofSeq(xs), ofSeq(ys)], (i, tupledArg) => {\n        const e1 = tupledArg[0];\n        const e2 = tupledArg[1];\n        if (i === index) {\n            status = 0;\n        }\n        let inserted;\n        if (status === 0) {\n            if (e2[\"System.Collections.IEnumerator.MoveNext\"]()) {\n                inserted = some(e2[\"System.Collections.Generic.IEnumerator`1.get_Current\"]());\n            }\n            else {\n                status = 1;\n                inserted = void 0;\n            }\n        }\n        else {\n            inserted = void 0;\n        }\n        if (inserted == null) {\n            if (e1[\"System.Collections.IEnumerator.MoveNext\"]()) {\n                return some(e1[\"System.Collections.Generic.IEnumerator`1.get_Current\"]());\n            }\n            else {\n                if (status < 1) {\n                    throw new Error((SR_indexOutOfBounds + \"\\\\nParameter name: \") + \"index\");\n                }\n                return void 0;\n            }\n        }\n        else {\n            return some(value_1(inserted));\n        }\n    }, (tupledArg_1) => {\n        disposeSafe(tupledArg_1[0]);\n        disposeSafe(tupledArg_1[1]);\n    });\n}\nexport function removeAt(index, xs) {\n    let isDone = false;\n    if (index < 0) {\n        throw new Error((SR_indexOutOfBounds + \"\\\\nParameter name: \") + \"index\");\n    }\n    return generateIndexed(() => ofSeq(xs), (i, e) => {\n        if ((isDone ? true : (i < index)) && e[\"System.Collections.IEnumerator.MoveNext\"]()) {\n            return some(e[\"System.Collections.Generic.IEnumerator`1.get_Current\"]());\n        }\n        else if ((i === index) && e[\"System.Collections.IEnumerator.MoveNext\"]()) {\n            isDone = true;\n            return e[\"System.Collections.IEnumerator.MoveNext\"]() ? some(e[\"System.Collections.Generic.IEnumerator`1.get_Current\"]()) : void 0;\n        }\n        else {\n            if (!isDone) {\n                throw new Error((SR_indexOutOfBounds + \"\\\\nParameter name: \") + \"index\");\n            }\n            return void 0;\n        }\n    }, (e_1) => {\n        disposeSafe(e_1);\n    });\n}\nexport function removeManyAt(index, count, xs) {\n    if (index < 0) {\n        throw new Error((SR_indexOutOfBounds + \"\\\\nParameter name: \") + \"index\");\n    }\n    return generateIndexed(() => ofSeq(xs), (i, e) => {\n        if (i < index) {\n            if (e[\"System.Collections.IEnumerator.MoveNext\"]()) {\n                return some(e[\"System.Collections.Generic.IEnumerator`1.get_Current\"]());\n            }\n            else {\n                throw new Error((SR_indexOutOfBounds + \"\\\\nParameter name: \") + \"index\");\n            }\n        }\n        else {\n            if (i === index) {\n                for (let _ = 1; _ <= count; _++) {\n                    if (!e[\"System.Collections.IEnumerator.MoveNext\"]()) {\n                        throw new Error((SR_indexOutOfBounds + \"\\\\nParameter name: \") + \"count\");\n                    }\n                }\n            }\n            return e[\"System.Collections.IEnumerator.MoveNext\"]() ? some(e[\"System.Collections.Generic.IEnumerator`1.get_Current\"]()) : void 0;\n        }\n    }, (e_1) => {\n        disposeSafe(e_1);\n    });\n}\nexport function updateAt(index, y, xs) {\n    let isDone = false;\n    if (index < 0) {\n        throw new Error((SR_indexOutOfBounds + \"\\\\nParameter name: \") + \"index\");\n    }\n    return generateIndexed(() => ofSeq(xs), (i, e) => {\n        if ((isDone ? true : (i < index)) && e[\"System.Collections.IEnumerator.MoveNext\"]()) {\n            return some(e[\"System.Collections.Generic.IEnumerator`1.get_Current\"]());\n        }\n        else if ((i === index) && e[\"System.Collections.IEnumerator.MoveNext\"]()) {\n            isDone = true;\n            return some(y);\n        }\n        else {\n            if (!isDone) {\n                throw new Error((SR_indexOutOfBounds + \"\\\\nParameter name: \") + \"index\");\n            }\n            return void 0;\n        }\n    }, (e_1) => {\n        disposeSafe(e_1);\n    });\n}\n","import { disposeSafe, defaultOf, structuralHash, equals } from \"./Util.js\";\nimport { HashIdentity_Structural, ComparisonIdentity_Structural } from \"./FSharp.Collections.js\";\nimport { StringBuilder__Append_Z721C83C5 } from \"./System.Text.js\";\nexport const LanguagePrimitives_GenericEqualityComparer = {\n    \"System.Collections.IEqualityComparer.Equals541DA560\"(x, y) {\n        return equals(x, y);\n    },\n    \"System.Collections.IEqualityComparer.GetHashCode4E60E31B\"(x_1) {\n        return structuralHash(x_1);\n    },\n};\nexport const LanguagePrimitives_GenericEqualityERComparer = {\n    \"System.Collections.IEqualityComparer.Equals541DA560\"(x, y) {\n        return equals(x, y);\n    },\n    \"System.Collections.IEqualityComparer.GetHashCode4E60E31B\"(x_1) {\n        return structuralHash(x_1);\n    },\n};\nexport function LanguagePrimitives_FastGenericComparer() {\n    return ComparisonIdentity_Structural();\n}\nexport function LanguagePrimitives_FastGenericComparerFromTable() {\n    return ComparisonIdentity_Structural();\n}\nexport function LanguagePrimitives_FastGenericEqualityComparer() {\n    return HashIdentity_Structural();\n}\nexport function LanguagePrimitives_FastGenericEqualityComparerFromTable() {\n    return HashIdentity_Structural();\n}\nexport function Operators_Failure(message) {\n    return new Error(message);\n}\nexport function Operators_FailurePattern(exn) {\n    return exn.message;\n}\nexport function Operators_NullArg(x) {\n    throw new Error(x);\n}\nexport function Operators_Using(resource, action) {\n    try {\n        return action(resource);\n    }\n    finally {\n        if (equals(resource, defaultOf())) {\n        }\n        else {\n            let copyOfStruct = resource;\n            disposeSafe(copyOfStruct);\n        }\n    }\n}\nexport function Operators_Lock(_lockObj, action) {\n    return action();\n}\nexport function ExtraTopLevelOperators_LazyPattern(input) {\n    return input.Value;\n}\nexport function PrintfModule_PrintFormatToStringBuilderThen(continuation, builder, format) {\n    return format.cont((s) => {\n        StringBuilder__Append_Z721C83C5(builder, s);\n        return continuation();\n    });\n}\nexport function PrintfModule_PrintFormatToStringBuilder(builder, format) {\n    return PrintfModule_PrintFormatToStringBuilderThen(() => {\n    }, builder, format);\n}\n","/**\n * DateTimeOffset functions.\n *\n * Note: Date instances are always DateObjects in local\n * timezone (because JS dates are all kinds of messed up).\n * A local date returns UTC epoch when `.getTime()` is called.\n *\n * Basically; invariant: date.getTime() always return UTC time.\n */\nimport { toInt64, toFloat64 } from \"./BigInt.js\";\nimport { compareDates, dateOffset, padWithZeros } from \"./Util.js\";\nexport function kind(value) {\n    return value.kind || 0;\n}\nexport function unixEpochMillisecondsToTicks(ms, offset) {\n    return toInt64(((BigInt(ms) + 62135596800000n) + BigInt(offset)) * 10000n);\n}\nexport function ticksToUnixEpochMilliseconds(ticks) {\n    return Number(((BigInt(ticks) / 10000n) - 62135596800000n));\n}\nexport function dateOffsetToString(offset) {\n    const isMinus = offset < 0;\n    offset = Math.abs(offset);\n    const hours = ~~(offset / 3600000);\n    const minutes = (offset % 3600000) / 60000;\n    return (isMinus ? \"-\" : \"+\") +\n        padWithZeros(hours, 2) + \":\" +\n        padWithZeros(minutes, 2);\n}\nexport function dateToHalfUTCString(date, half) {\n    const str = date.toISOString();\n    return half === \"first\"\n        ? str.substring(0, str.indexOf(\"T\"))\n        : str.substring(str.indexOf(\"T\") + 1, str.length - 1);\n}\nfunction dateToISOString(d, utc) {\n    if (utc) {\n        return d.toISOString();\n    }\n    else {\n        // JS Date is always local\n        const printOffset = d.kind == null ? true : d.kind === 2 /* DateKind.Local */;\n        return padWithZeros(d.getFullYear(), 4) + \"-\" +\n            padWithZeros(d.getMonth() + 1, 2) + \"-\" +\n            padWithZeros(d.getDate(), 2) + \"T\" +\n            padWithZeros(d.getHours(), 2) + \":\" +\n            padWithZeros(d.getMinutes(), 2) + \":\" +\n            padWithZeros(d.getSeconds(), 2) + \".\" +\n            padWithZeros(d.getMilliseconds(), 3) +\n            (printOffset ? dateOffsetToString(d.getTimezoneOffset() * -60000) : \"\");\n    }\n}\nfunction dateToISOStringWithOffset(dateWithOffset, offset) {\n    const str = dateWithOffset.toISOString();\n    return str.substring(0, str.length - 1) + dateOffsetToString(offset);\n}\nfunction dateToStringWithCustomFormat(date, format, utc) {\n    return format.replace(/(\\w)\\1*/g, (match) => {\n        let rep = Number.NaN;\n        switch (match.substring(0, 1)) {\n            case \"y\":\n                const y = utc ? date.getUTCFullYear() : date.getFullYear();\n                rep = match.length < 4 ? y % 100 : y;\n                break;\n            case \"M\":\n                rep = (utc ? date.getUTCMonth() : date.getMonth()) + 1;\n                break;\n            case \"d\":\n                rep = utc ? date.getUTCDate() : date.getDate();\n                break;\n            case \"H\":\n                rep = utc ? date.getUTCHours() : date.getHours();\n                break;\n            case \"h\":\n                const h = utc ? date.getUTCHours() : date.getHours();\n                rep = h > 12 ? h % 12 : h;\n                break;\n            case \"m\":\n                rep = utc ? date.getUTCMinutes() : date.getMinutes();\n                break;\n            case \"s\":\n                rep = utc ? date.getUTCSeconds() : date.getSeconds();\n                break;\n            case \"f\":\n                rep = utc ? date.getUTCMilliseconds() : date.getMilliseconds();\n                break;\n        }\n        if (Number.isNaN(rep)) {\n            return match;\n        }\n        else {\n            return padWithZeros(rep, match.length);\n        }\n    });\n}\nfunction dateToStringWithOffset(date, format) {\n    const d = new Date(date.getTime() + (date.offset ?? 0));\n    if (typeof format !== \"string\") {\n        return d.toISOString().replace(/\\.\\d+/, \"\").replace(/[A-Z]|\\.\\d+/g, \" \") + dateOffsetToString((date.offset ?? 0));\n    }\n    else if (format.length === 1) {\n        switch (format) {\n            case \"D\":\n            case \"d\": return dateToHalfUTCString(d, \"first\");\n            case \"T\":\n            case \"t\": return dateToHalfUTCString(d, \"second\");\n            case \"O\":\n            case \"o\": return dateToISOStringWithOffset(d, (date.offset ?? 0));\n            default: throw new Error(\"Unrecognized Date print format\");\n        }\n    }\n    else {\n        return dateToStringWithCustomFormat(d, format, true);\n    }\n}\nfunction dateToStringWithKind(date, format) {\n    const utc = date.kind === 1 /* DateKind.UTC */;\n    if (typeof format !== \"string\") {\n        return utc ? date.toUTCString() : date.toLocaleString();\n    }\n    else if (format.length === 1) {\n        switch (format) {\n            case \"D\":\n            case \"d\":\n                return utc ? dateToHalfUTCString(date, \"first\") : date.toLocaleDateString();\n            case \"T\":\n            case \"t\":\n                return utc ? dateToHalfUTCString(date, \"second\") : date.toLocaleTimeString();\n            case \"O\":\n            case \"o\":\n                return dateToISOString(date, utc);\n            default:\n                throw new Error(\"Unrecognized Date print format\");\n        }\n    }\n    else {\n        return dateToStringWithCustomFormat(date, format, utc);\n    }\n}\nexport function toString(date, format, _provider) {\n    return date.offset != null\n        ? dateToStringWithOffset(date, format)\n        : dateToStringWithKind(date, format);\n}\nexport function DateTime(value, kind) {\n    const d = new Date(value);\n    d.kind = (kind == null ? 0 /* DateKind.Unspecified */ : kind) | 0;\n    return d;\n}\nexport function fromTicks(ticks, kind) {\n    kind = kind != null ? kind : 2 /* DateKind.Local */; // better default than Unspecified\n    let date = DateTime(ticksToUnixEpochMilliseconds(ticks), kind);\n    // Ticks are local to offset (in this case, either UTC or Local/Unknown).\n    // If kind is anything but UTC, that means that the tick number was not\n    // in utc, thus getTime() cannot return UTC, and needs to be shifted.\n    if (kind !== 1 /* DateKind.UTC */) {\n        date = DateTime(date.getTime() - dateOffset(date), kind);\n    }\n    return date;\n}\nexport function fromDateTimeOffset(date, kind) {\n    switch (kind) {\n        case 1 /* DateKind.UTC */: return DateTime(date.getTime(), 1 /* DateKind.UTC */);\n        case 2 /* DateKind.Local */: return DateTime(date.getTime(), 2 /* DateKind.Local */);\n        default:\n            const d = DateTime(date.getTime() + (date.offset ?? 0), kind);\n            return DateTime(d.getTime() - dateOffset(d), kind);\n    }\n}\nexport function getTicks(date) {\n    return unixEpochMillisecondsToTicks(date.getTime(), dateOffset(date));\n}\nexport function minValue() {\n    // This is \"0001-01-01T00:00:00.000Z\", actual JS min value is -8640000000000000\n    return DateTime(-62135596800000, 0 /* DateKind.Unspecified */);\n}\nexport function maxValue() {\n    // This is \"9999-12-31T23:59:59.999Z\", actual JS max value is 8640000000000000\n    return DateTime(253402300799999, 0 /* DateKind.Unspecified */);\n}\nexport function parseRaw(input) {\n    function fail() {\n        throw new Error(`The string is not a valid Date: ${input}`);\n    }\n    if (input == null || input.trim() === \"\") {\n        fail();\n    }\n    // ISO dates without TZ are parsed as UTC. Adding time without TZ keeps them local.\n    if (input.length === 10 && input[4] === \"-\" && input[7] === \"-\") {\n        input += \"T00:00:00\";\n    }\n    let date = new Date(input);\n    let offset = null;\n    if (isNaN(date.getTime())) {\n        // Try to check strings JS Date cannot parse (see #1045, #1422)\n        // tslint:disable-next-line:max-line-length\n        const m = /^\\s*(\\d+[^\\w\\s:]\\d+[^\\w\\s:]\\d+)?\\s*(\\d+:\\d+(?::\\d+(?:\\.\\d+)?)?)?\\s*([AaPp][Mm])?\\s*(Z|[+-]([01]?\\d):?([0-5]?\\d)?)?\\s*$/.exec(input);\n        if (m != null) {\n            let baseDate;\n            let timeInSeconds = 0;\n            if (m[2] != null) {\n                const timeParts = m[2].split(\":\");\n                timeInSeconds =\n                    parseInt(timeParts[0], 10) * 3600 +\n                        parseInt(timeParts[1] || \"0\", 10) * 60 +\n                        parseFloat(timeParts[2] || \"0\");\n                if (m[3] != null && m[3].toUpperCase() === \"PM\") {\n                    timeInSeconds += 720;\n                }\n            }\n            if (m[4] != null) { // There's an offset, parse as UTC\n                if (m[1] != null) {\n                    baseDate = new Date(m[1] + \" UTC\");\n                }\n                else {\n                    const d = new Date();\n                    baseDate = new Date(d.getUTCFullYear() + \"/\" + (d.getUTCMonth() + 1) + \"/\" + d.getUTCDate());\n                }\n                if (m[4] === \"Z\") {\n                    offset = \"Z\";\n                }\n                else {\n                    let offsetInMinutes = parseInt(m[5], 10) * 60 + parseInt(m[6] || \"0\", 10);\n                    if (m[4][0] === \"-\") {\n                        offsetInMinutes *= -1;\n                    }\n                    offset = offsetInMinutes;\n                    timeInSeconds -= offsetInMinutes * 60;\n                }\n            }\n            else {\n                if (m[1] != null) {\n                    baseDate = new Date(m[1]);\n                }\n                else {\n                    const d = new Date();\n                    baseDate = new Date(d.getFullYear() + \"/\" + (d.getMonth() + 1) + \"/\" + d.getDate());\n                }\n            }\n            date = new Date(baseDate.getTime() + timeInSeconds * 1000);\n            // correct for daylight savings time\n            date = new Date(date.getTime() + (date.getTimezoneOffset() - baseDate.getTimezoneOffset()) * 60000);\n        }\n        else {\n            fail();\n        }\n        // Check again the date is valid after transformations, see #2229\n        if (isNaN(date.getTime())) {\n            fail();\n        }\n    }\n    return [date, offset];\n}\nexport function parse(str, detectUTC = false) {\n    const [date, offset] = parseRaw(str);\n    // .NET always parses DateTime as Local if there's offset info (even \"Z\")\n    // Newtonsoft.Json uses UTC if the offset is \"Z\"\n    const kind = offset != null\n        ? (detectUTC && offset === \"Z\" ? 1 /* DateKind.UTC */ : 2 /* DateKind.Local */)\n        : 0 /* DateKind.Unspecified */;\n    return DateTime(date.getTime(), kind);\n}\nexport function tryParse(v, defValue) {\n    try {\n        defValue.contents = parse(v);\n        return true;\n    }\n    catch (_err) {\n        return false;\n    }\n}\nexport function create(year, month, day, h = 0, m = 0, s = 0, ms = 0, kind) {\n    const date = kind === 1 /* DateKind.UTC */\n        ? new Date(Date.UTC(year, month - 1, day, h, m, s, ms))\n        : new Date(year, month - 1, day, h, m, s, ms);\n    if (year <= 99) {\n        if (kind === 1 /* DateKind.UTC */) {\n            date.setUTCFullYear(year, month - 1, day);\n        }\n        else {\n            date.setFullYear(year, month - 1, day);\n        }\n    }\n    const dateValue = date.getTime();\n    if (isNaN(dateValue)) {\n        throw new Error(\"The parameters describe an unrepresentable Date.\");\n    }\n    return DateTime(dateValue, kind);\n}\nexport function now() {\n    return DateTime(Date.now(), 2 /* DateKind.Local */);\n}\nexport function utcNow() {\n    return DateTime(Date.now(), 1 /* DateKind.UTC */);\n}\nexport function today() {\n    return date(now());\n}\nexport function isLeapYear(year) {\n    return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;\n}\nexport function daysInMonth(year, month) {\n    return month === 2\n        ? (isLeapYear(year) ? 29 : 28)\n        : (month >= 8 ? (month % 2 === 0 ? 31 : 30) : (month % 2 === 0 ? 30 : 31));\n}\nexport function toUniversalTime(date) {\n    return date.kind === 1 /* DateKind.UTC */ ? date : DateTime(date.getTime(), 1 /* DateKind.UTC */);\n}\nexport function toLocalTime(date) {\n    return date.kind === 2 /* DateKind.Local */ ? date : DateTime(date.getTime(), 2 /* DateKind.Local */);\n}\nexport function specifyKind(d, kind) {\n    return create(year(d), month(d), day(d), hour(d), minute(d), second(d), millisecond(d), kind);\n}\nexport function timeOfDay(d) {\n    return hour(d) * 3600000\n        + minute(d) * 60000\n        + second(d) * 1000\n        + millisecond(d);\n}\nexport function date(d) {\n    return create(year(d), month(d), day(d), 0, 0, 0, 0, d.kind);\n}\nexport function day(d) {\n    return d.kind === 1 /* DateKind.UTC */ ? d.getUTCDate() : d.getDate();\n}\nexport function hour(d) {\n    return d.kind === 1 /* DateKind.UTC */ ? d.getUTCHours() : d.getHours();\n}\nexport function millisecond(d) {\n    return d.kind === 1 /* DateKind.UTC */ ? d.getUTCMilliseconds() : d.getMilliseconds();\n}\nexport function minute(d) {\n    return d.kind === 1 /* DateKind.UTC */ ? d.getUTCMinutes() : d.getMinutes();\n}\nexport function month(d) {\n    return (d.kind === 1 /* DateKind.UTC */ ? d.getUTCMonth() : d.getMonth()) + 1;\n}\nexport function second(d) {\n    return d.kind === 1 /* DateKind.UTC */ ? d.getUTCSeconds() : d.getSeconds();\n}\nexport function year(d) {\n    return d.kind === 1 /* DateKind.UTC */ ? d.getUTCFullYear() : d.getFullYear();\n}\nexport function dayOfWeek(d) {\n    return d.kind === 1 /* DateKind.UTC */ ? d.getUTCDay() : d.getDay();\n}\nexport function dayOfYear(d) {\n    const _year = year(d);\n    const _month = month(d);\n    let _day = day(d);\n    for (let i = 1; i < _month; i++) {\n        _day += daysInMonth(_year, i);\n    }\n    return _day;\n}\nexport function add(d, ts) {\n    const newDate = DateTime(d.getTime() + ts, d.kind);\n    if (d.kind === 2 /* DateKind.Local */) {\n        const oldTzOffset = d.getTimezoneOffset();\n        const newTzOffset = newDate.getTimezoneOffset();\n        return oldTzOffset !== newTzOffset\n            ? DateTime(newDate.getTime() + (newTzOffset - oldTzOffset) * 60000, d.kind)\n            : newDate;\n    }\n    else {\n        return newDate;\n    }\n}\nexport function addDays(d, v) {\n    return add(d, v * 86400000);\n}\nexport function addHours(d, v) {\n    return add(d, v * 3600000);\n}\nexport function addMinutes(d, v) {\n    return add(d, v * 60000);\n}\nexport function addSeconds(d, v) {\n    return add(d, v * 1000);\n}\nexport function addMilliseconds(d, v) {\n    return add(d, v);\n}\nexport function addTicks(d, v) {\n    return add(d, toFloat64(v / 10000n));\n}\nexport function addYears(d, v) {\n    const newMonth = month(d);\n    const newYear = year(d) + v;\n    const _daysInMonth = daysInMonth(newYear, newMonth);\n    const newDay = Math.min(_daysInMonth, day(d));\n    return create(newYear, newMonth, newDay, hour(d), minute(d), second(d), millisecond(d), d.kind);\n}\nexport function addMonths(d, v) {\n    let newMonth = month(d) + v;\n    let newMonth_ = 0;\n    let yearOffset = 0;\n    if (newMonth > 12) {\n        newMonth_ = newMonth % 12;\n        yearOffset = Math.floor(newMonth / 12);\n        newMonth = newMonth_;\n    }\n    else if (newMonth < 1) {\n        newMonth_ = 12 + newMonth % 12;\n        yearOffset = Math.floor(newMonth / 12) + (newMonth_ === 12 ? -1 : 0);\n        newMonth = newMonth_;\n    }\n    const newYear = year(d) + yearOffset;\n    const _daysInMonth = daysInMonth(newYear, newMonth);\n    const newDay = Math.min(_daysInMonth, day(d));\n    return create(newYear, newMonth, newDay, hour(d), minute(d), second(d), millisecond(d), d.kind);\n}\nexport function subtract(d, that) {\n    return typeof that === \"number\"\n        ? add(d, -that)\n        : d.getTime() - that.getTime();\n}\nexport function toLongDateString(d) {\n    return d.toDateString();\n}\nexport function toShortDateString(d) {\n    return d.toLocaleDateString();\n}\nexport function toLongTimeString(d) {\n    return d.toLocaleTimeString();\n}\nexport function toShortTimeString(d) {\n    return d.toLocaleTimeString().replace(/:\\d\\d(?!:)/, \"\");\n}\nexport function equals(d1, d2) {\n    return d1.getTime() === d2.getTime();\n}\nexport const compare = compareDates;\nexport const compareTo = compareDates;\nexport function op_Addition(x, y) {\n    return add(x, y);\n}\nexport function op_Subtraction(x, y) {\n    return subtract(x, y);\n}\nexport function isDaylightSavingTime(x) {\n    const jan = new Date(x.getFullYear(), 0, 1);\n    const jul = new Date(x.getFullYear(), 6, 1);\n    return isDST(jan.getTimezoneOffset(), jul.getTimezoneOffset(), x.getTimezoneOffset());\n}\nfunction isDST(janOffset, julOffset, tOffset) {\n    return Math.min(janOffset, julOffset) === tOffset;\n}\nexport default DateTime;\n","export const symbol = Symbol(\"numeric\");\nexport function isNumeric(x) {\n    return typeof x === \"number\" || typeof x === \"bigint\" || x?.[symbol];\n}\nexport function compare(x, y) {\n    if (typeof x === \"number\") {\n        return x < y ? -1 : (x > y ? 1 : 0);\n    }\n    else if (typeof x === \"bigint\") {\n        return x < y ? -1 : (x > y ? 1 : 0);\n    }\n    else {\n        return x.CompareTo(y);\n    }\n}\nexport function multiply(x, y) {\n    if (typeof x === \"number\") {\n        return x * y;\n    }\n    else if (typeof x === \"bigint\") {\n        return x * BigInt(y);\n    }\n    else {\n        return x[symbol]().multiply(y);\n    }\n}\nexport function toFixed(x, dp) {\n    if (typeof x === \"number\") {\n        return x.toFixed(dp);\n    }\n    else if (typeof x === \"bigint\") {\n        return x;\n    }\n    else {\n        return x[symbol]().toFixed(dp);\n    }\n}\nexport function toPrecision(x, sd) {\n    if (typeof x === \"number\") {\n        return x.toPrecision(sd);\n    }\n    else if (typeof x === \"bigint\") {\n        return x;\n    }\n    else {\n        return x[symbol]().toPrecision(sd);\n    }\n}\nexport function toExponential(x, dp) {\n    if (typeof x === \"number\") {\n        return x.toExponential(dp);\n    }\n    else if (typeof x === \"bigint\") {\n        return x;\n    }\n    else {\n        return x[symbol]().toExponential(dp);\n    }\n}\nexport function toHex(x) {\n    if (typeof x === \"number\") {\n        return (Number(x) >>> 0).toString(16);\n    }\n    else if (typeof x === \"bigint\") {\n        // TODO: properly handle other bit sizes\n        return BigInt.asUintN(64, x).toString(16);\n    }\n    else {\n        return x[symbol]().toHex();\n    }\n}\n","import { toString as dateToString } from \"./Date.js\";\nimport { compare as numericCompare, isNumeric, multiply, toExponential, toFixed, toHex, toPrecision } from \"./Numeric.js\";\nimport { escape } from \"./RegExp.js\";\nimport { toString } from \"./Types.js\";\nconst fsFormatRegExp = /(^|[^%])%([0+\\- ]*)(\\*|\\d+)?(?:\\.(\\d+))?(\\w)/g;\nconst interpolateRegExp = /(?:(^|[^%])%([0+\\- ]*)(\\d+)?(?:\\.(\\d+))?(\\w))?%P\\(\\)/g;\nconst formatRegExp = /\\{(\\d+)(,-?\\d+)?(?:\\:([a-zA-Z])(\\d{0,2})|\\:(.+?))?\\}/g;\nfunction isLessThan(x, y) {\n    return numericCompare(x, y) < 0;\n}\nfunction cmp(x, y, ic) {\n    function isIgnoreCase(i) {\n        return i === true ||\n            i === 1 /* StringComparison.CurrentCultureIgnoreCase */ ||\n            i === 3 /* StringComparison.InvariantCultureIgnoreCase */ ||\n            i === 5 /* StringComparison.OrdinalIgnoreCase */;\n    }\n    function isOrdinal(i) {\n        return i === 4 /* StringComparison.Ordinal */ ||\n            i === 5 /* StringComparison.OrdinalIgnoreCase */;\n    }\n    if (x == null) {\n        return y == null ? 0 : -1;\n    }\n    if (y == null) {\n        return 1;\n    } // everything is bigger than null\n    if (isOrdinal(ic)) {\n        if (isIgnoreCase(ic)) {\n            x = x.toLowerCase();\n            y = y.toLowerCase();\n        }\n        return (x === y) ? 0 : (x < y ? -1 : 1);\n    }\n    else {\n        if (isIgnoreCase(ic)) {\n            x = x.toLocaleLowerCase();\n            y = y.toLocaleLowerCase();\n        }\n        return x.localeCompare(y);\n    }\n}\nexport function compare(...args) {\n    switch (args.length) {\n        case 2: return cmp(args[0], args[1], false);\n        case 3: return cmp(args[0], args[1], args[2]);\n        case 4: return cmp(args[0], args[1], args[2] === true);\n        case 5: return cmp(args[0].substr(args[1], args[4]), args[2].substr(args[3], args[4]), false);\n        case 6: return cmp(args[0].substr(args[1], args[4]), args[2].substr(args[3], args[4]), args[5]);\n        case 7: return cmp(args[0].substr(args[1], args[4]), args[2].substr(args[3], args[4]), args[5] === true);\n        default: throw new Error(\"String.compare: Unsupported number of parameters\");\n    }\n}\nexport function compareOrdinal(x, y) {\n    return cmp(x, y, 4 /* StringComparison.Ordinal */);\n}\nexport function compareTo(x, y) {\n    return cmp(x, y, 0 /* StringComparison.CurrentCulture */);\n}\nexport function startsWith(str, pattern, ic) {\n    if (str.length >= pattern.length) {\n        return cmp(str.substr(0, pattern.length), pattern, ic) === 0;\n    }\n    return false;\n}\nexport function indexOfAny(str, anyOf, ...args) {\n    if (str == null || str === \"\") {\n        return -1;\n    }\n    const startIndex = (args.length > 0) ? args[0] : 0;\n    if (startIndex < 0) {\n        throw new Error(\"Start index cannot be negative\");\n    }\n    const length = (args.length > 1) ? args[1] : str.length - startIndex;\n    if (length < 0) {\n        throw new Error(\"Length cannot be negative\");\n    }\n    if (startIndex + length > str.length) {\n        throw new Error(\"Invalid startIndex and length\");\n    }\n    str = str.substring(startIndex, startIndex + length);\n    for (const c of anyOf) {\n        const index = str.indexOf(c);\n        if (index > -1) {\n            return index + startIndex;\n        }\n    }\n    return -1;\n}\nexport function printf(input) {\n    return {\n        input,\n        cont: fsFormat(input),\n    };\n}\nexport function interpolate(str, values) {\n    let valIdx = 0;\n    let strIdx = 0;\n    let result = \"\";\n    interpolateRegExp.lastIndex = 0;\n    let match = interpolateRegExp.exec(str);\n    while (match) {\n        // The first group corresponds to the no-escape char (^|[^%]), the actual pattern starts in the next char\n        // Note: we don't use negative lookbehind because some browsers don't support it yet\n        const matchIndex = match.index + (match[1] || \"\").length;\n        result += str.substring(strIdx, matchIndex).replace(/%%/g, \"%\");\n        const [, , flags, padLength, precision, format] = match;\n        // Save interpolateRegExp.lastIndex before running formatReplacement because the values\n        // may also involve interpolation and make use of interpolateRegExp (see #3078)\n        strIdx = interpolateRegExp.lastIndex;\n        result += formatReplacement(values[valIdx++], flags, padLength, precision, format);\n        // Move interpolateRegExp.lastIndex one char behind to make sure we match the no-escape char next time\n        interpolateRegExp.lastIndex = strIdx - 1;\n        match = interpolateRegExp.exec(str);\n    }\n    result += str.substring(strIdx).replace(/%%/g, \"%\");\n    return result;\n}\nfunction continuePrint(cont, arg) {\n    return typeof arg === \"string\" ? cont(arg) : arg.cont(cont);\n}\nexport function toConsole(arg) {\n    // Don't remove the lambda here, see #1357\n    return continuePrint((x) => console.log(x), arg);\n}\nexport function toConsoleError(arg) {\n    return continuePrint((x) => console.error(x), arg);\n}\nexport function toText(arg) {\n    return continuePrint((x) => x, arg);\n}\nexport function toFail(arg) {\n    return continuePrint((x) => {\n        throw new Error(x);\n    }, arg);\n}\nfunction formatReplacement(rep, flags, padLength, precision, format) {\n    let sign = \"\";\n    flags = flags || \"\";\n    format = format || \"\";\n    if (isNumeric(rep)) {\n        if (format.toLowerCase() !== \"x\") {\n            if (isLessThan(rep, 0)) {\n                rep = multiply(rep, -1);\n                sign = \"-\";\n            }\n            else {\n                if (flags.indexOf(\" \") >= 0) {\n                    sign = \" \";\n                }\n                else if (flags.indexOf(\"+\") >= 0) {\n                    sign = \"+\";\n                }\n            }\n        }\n        precision = precision == null ? null : parseInt(precision, 10);\n        switch (format) {\n            case \"f\":\n            case \"F\":\n                precision = precision != null ? precision : 6;\n                rep = toFixed(rep, precision);\n                break;\n            case \"g\":\n            case \"G\":\n                rep = precision != null ? toPrecision(rep, precision) : toPrecision(rep);\n                break;\n            case \"e\":\n            case \"E\":\n                rep = precision != null ? toExponential(rep, precision) : toExponential(rep);\n                break;\n            case \"x\":\n                rep = toHex(rep);\n                break;\n            case \"X\":\n                rep = toHex(rep).toUpperCase();\n                break;\n            default: // AOid\n                rep = String(rep);\n                break;\n        }\n    }\n    else if (rep instanceof Date) {\n        rep = dateToString(rep);\n    }\n    else {\n        rep = toString(rep);\n    }\n    padLength = typeof padLength === \"number\" ? padLength : parseInt(padLength, 10);\n    if (!isNaN(padLength)) {\n        const zeroFlag = flags.indexOf(\"0\") >= 0; // Use '0' for left padding\n        const minusFlag = flags.indexOf(\"-\") >= 0; // Right padding\n        const ch = minusFlag || !zeroFlag ? \" \" : \"0\";\n        if (ch === \"0\") {\n            rep = pad(rep, padLength - sign.length, ch, minusFlag);\n            rep = sign + rep;\n        }\n        else {\n            rep = pad(sign + rep, padLength, ch, minusFlag);\n        }\n    }\n    else {\n        rep = sign + rep;\n    }\n    return rep;\n}\nfunction createPrinter(cont, _strParts, _matches, _result = \"\", padArg = -1) {\n    return (...args) => {\n        // Make copies of the values passed by reference because the function can be used multiple times\n        let result = _result;\n        const strParts = _strParts.slice();\n        const matches = _matches.slice();\n        for (const arg of args) {\n            const [, , flags, _padLength, precision, format] = matches[0];\n            let padLength = _padLength;\n            if (padArg >= 0) {\n                padLength = padArg;\n                padArg = -1;\n            }\n            else if (padLength === \"*\") {\n                if (arg < 0) {\n                    throw new Error(\"Non-negative number required\");\n                }\n                padArg = arg;\n                continue;\n            }\n            result += strParts[0];\n            result += formatReplacement(arg, flags, padLength, precision, format);\n            strParts.splice(0, 1);\n            matches.splice(0, 1);\n        }\n        if (matches.length === 0) {\n            result += strParts[0];\n            return cont(result);\n        }\n        else {\n            return createPrinter(cont, strParts, matches, result, padArg);\n        }\n    };\n}\nexport function fsFormat(str) {\n    return (cont) => {\n        fsFormatRegExp.lastIndex = 0;\n        const strParts = [];\n        const matches = [];\n        let strIdx = 0;\n        let match = fsFormatRegExp.exec(str);\n        while (match) {\n            // The first group corresponds to the no-escape char (^|[^%]), the actual pattern starts in the next char\n            // Note: we don't use negative lookbehind because some browsers don't support it yet\n            const matchIndex = match.index + (match[1] || \"\").length;\n            strParts.push(str.substring(strIdx, matchIndex).replace(/%%/g, \"%\"));\n            matches.push(match);\n            strIdx = fsFormatRegExp.lastIndex;\n            // Likewise we need to move fsFormatRegExp.lastIndex one char behind to make sure we match the no-escape char next time\n            fsFormatRegExp.lastIndex -= 1;\n            match = fsFormatRegExp.exec(str);\n        }\n        if (strParts.length === 0) {\n            return cont(str.replace(/%%/g, \"%\"));\n        }\n        else {\n            strParts.push(str.substring(strIdx).replace(/%%/g, \"%\"));\n            return createPrinter(cont, strParts, matches);\n        }\n    };\n}\nexport function format(str, ...args) {\n    let str2;\n    if (typeof str === \"object\") {\n        // Called with culture info\n        str2 = String(args[0]);\n        args.shift();\n    }\n    else {\n        str2 = str;\n    }\n    return str2.replace(formatRegExp, (_, idx, padLength, format, precision, pattern) => {\n        if (idx < 0 || idx >= args.length) {\n            throw new Error(\"Index must be greater or equal to zero and less than the arguments' length.\");\n        }\n        let rep = args[idx];\n        if (isNumeric(rep)) {\n            precision = precision == null ? null : parseInt(precision, 10);\n            switch (format) {\n                case \"f\":\n                case \"F\":\n                    precision = precision != null ? precision : 2;\n                    rep = toFixed(rep, precision);\n                    break;\n                case \"g\":\n                case \"G\":\n                    rep = precision != null ? toPrecision(rep, precision) : toPrecision(rep);\n                    break;\n                case \"e\":\n                case \"E\":\n                    rep = precision != null ? toExponential(rep, precision) : toExponential(rep);\n                    break;\n                case \"p\":\n                case \"P\":\n                    precision = precision != null ? precision : 2;\n                    rep = toFixed(multiply(rep, 100), precision) + \" %\";\n                    break;\n                case \"d\":\n                case \"D\":\n                    rep = precision != null ? padLeft(String(rep), precision, \"0\") : String(rep);\n                    break;\n                case \"x\":\n                case \"X\":\n                    rep = precision != null ? padLeft(toHex(rep), precision, \"0\") : toHex(rep);\n                    if (format === \"X\") {\n                        rep = rep.toUpperCase();\n                    }\n                    break;\n                default:\n                    if (pattern) {\n                        let sign = \"\";\n                        rep = pattern.replace(/([0#,]+)(\\.[0#]+)?/, (_, intPart, decimalPart) => {\n                            if (isLessThan(rep, 0)) {\n                                rep = multiply(rep, -1);\n                                sign = \"-\";\n                            }\n                            decimalPart = decimalPart == null ? \"\" : decimalPart.substring(1);\n                            rep = toFixed(rep, Math.max(decimalPart.length, 0));\n                            let [repInt, repDecimal] = rep.split(\".\");\n                            repDecimal || (repDecimal = \"\");\n                            const leftZeroes = intPart.replace(/,/g, \"\").replace(/^#+/, \"\").length;\n                            repInt = padLeft(repInt, leftZeroes, \"0\");\n                            const rightZeros = decimalPart.replace(/#+$/, \"\").length;\n                            if (rightZeros > repDecimal.length) {\n                                repDecimal = padRight(repDecimal, rightZeros, \"0\");\n                            }\n                            else if (rightZeros < repDecimal.length) {\n                                repDecimal = repDecimal.substring(0, rightZeros) + repDecimal.substring(rightZeros).replace(/0+$/, \"\");\n                            }\n                            // Thousands separator\n                            if (intPart.indexOf(\",\") > 0) {\n                                const i = repInt.length % 3;\n                                const thousandGroups = Math.floor(repInt.length / 3);\n                                let thousands = i > 0 ? repInt.substr(0, i) + (thousandGroups > 0 ? \",\" : \"\") : \"\";\n                                for (let j = 0; j < thousandGroups; j++) {\n                                    thousands += repInt.substr(i + j * 3, 3) + (j < thousandGroups - 1 ? \",\" : \"\");\n                                }\n                                repInt = thousands;\n                            }\n                            return repDecimal.length > 0 ? repInt + \".\" + repDecimal : repInt;\n                        });\n                        rep = sign + rep;\n                    }\n            }\n        }\n        else if (rep instanceof Date) {\n            rep = dateToString(rep, pattern || format);\n        }\n        else {\n            rep = toString(rep);\n        }\n        padLength = parseInt((padLength || \" \").substring(1), 10);\n        if (!isNaN(padLength)) {\n            rep = pad(String(rep), Math.abs(padLength), \" \", padLength < 0);\n        }\n        return rep;\n    });\n}\nexport function endsWith(str, search) {\n    const idx = str.lastIndexOf(search);\n    return idx >= 0 && idx === str.length - search.length;\n}\nexport function initialize(n, f) {\n    if (n < 0) {\n        throw new Error(\"String length must be non-negative\");\n    }\n    const xs = new Array(n);\n    for (let i = 0; i < n; i++) {\n        xs[i] = f(i);\n    }\n    return xs.join(\"\");\n}\nexport function insert(str, startIndex, value) {\n    if (startIndex < 0 || startIndex > str.length) {\n        throw new Error(\"startIndex is negative or greater than the length of this instance.\");\n    }\n    return str.substring(0, startIndex) + value + str.substring(startIndex);\n}\nexport function isNullOrEmpty(str) {\n    return typeof str !== \"string\" || str.length === 0;\n}\nexport function isNullOrWhiteSpace(str) {\n    return typeof str !== \"string\" || /^\\s*$/.test(str);\n}\nexport function concat(...xs) {\n    return xs.map((x) => String(x)).join(\"\");\n}\nexport function join(delimiter, xs) {\n    if (Array.isArray(xs)) {\n        return xs.join(delimiter);\n    }\n    else {\n        return Array.from(xs).join(delimiter);\n    }\n}\nexport function joinWithIndices(delimiter, xs, startIndex, count) {\n    const endIndexPlusOne = startIndex + count;\n    if (endIndexPlusOne > xs.length) {\n        throw new Error(\"Index and count must refer to a location within the buffer.\");\n    }\n    return xs.slice(startIndex, endIndexPlusOne).join(delimiter);\n}\nfunction notSupported(name) {\n    throw new Error(\"The environment doesn't support '\" + name + \"', please use a polyfill.\");\n}\nexport function toBase64String(inArray) {\n    let str = \"\";\n    for (let i = 0; i < inArray.length; i++) {\n        str += String.fromCharCode(inArray[i]);\n    }\n    return typeof btoa === \"function\" ? btoa(str) : notSupported(\"btoa\");\n}\nexport function fromBase64String(b64Encoded) {\n    const binary = typeof atob === \"function\" ? atob(b64Encoded) : notSupported(\"atob\");\n    const bytes = new Uint8Array(binary.length);\n    for (let i = 0; i < binary.length; i++) {\n        bytes[i] = binary.charCodeAt(i);\n    }\n    return bytes;\n}\nfunction pad(str, len, ch, isRight) {\n    ch = ch || \" \";\n    len = len - str.length;\n    for (let i = 0; i < len; i++) {\n        str = isRight ? str + ch : ch + str;\n    }\n    return str;\n}\nexport function padLeft(str, len, ch) {\n    return pad(str, len, ch);\n}\nexport function padRight(str, len, ch) {\n    return pad(str, len, ch, true);\n}\nexport function remove(str, startIndex, count) {\n    if (startIndex >= str.length) {\n        throw new Error(\"startIndex must be less than length of string\");\n    }\n    if (typeof count === \"number\" && (startIndex + count) > str.length) {\n        throw new Error(\"Index and count must refer to a location within the string.\");\n    }\n    return str.slice(0, startIndex) + (typeof count === \"number\" ? str.substr(startIndex + count) : \"\");\n}\nexport function replace(str, search, replace) {\n    return str.replace(new RegExp(escape(search), \"g\"), replace);\n}\nexport function replicate(n, x) {\n    return initialize(n, () => x);\n}\nexport function getCharAtIndex(input, index) {\n    if (index < 0 || index >= input.length) {\n        throw new Error(\"Index was outside the bounds of the array.\");\n    }\n    return input[index];\n}\nexport function split(str, splitters, count, options) {\n    count = typeof count === \"number\" ? count : undefined;\n    options = typeof options === \"number\" ? options : 0;\n    if (count && count < 0) {\n        throw new Error(\"Count cannot be less than zero\");\n    }\n    if (count === 0) {\n        return [];\n    }\n    const removeEmpty = (options & 1) === 1;\n    const trim = (options & 2) === 2;\n    splitters = splitters || [];\n    splitters = splitters.filter(x => x).map(escape);\n    splitters = splitters.length > 0 ? splitters : [\"\\\\s\"];\n    const splits = [];\n    const reg = new RegExp(splitters.join(\"|\"), \"g\");\n    let findSplits = true;\n    let i = 0;\n    do {\n        const match = reg.exec(str);\n        if (match === null) {\n            const candidate = trim ? str.substring(i).trim() : str.substring(i);\n            if (!removeEmpty || candidate.length > 0) {\n                splits.push(candidate);\n            }\n            findSplits = false;\n        }\n        else {\n            const candidate = trim ? str.substring(i, match.index).trim() : str.substring(i, match.index);\n            if (!removeEmpty || candidate.length > 0) {\n                if (count != null && splits.length + 1 === count) {\n                    splits.push(trim ? str.substring(i).trim() : str.substring(i));\n                    findSplits = false;\n                }\n                else {\n                    splits.push(candidate);\n                }\n            }\n            i = reg.lastIndex;\n        }\n    } while (findSplits);\n    return splits;\n}\nexport function trim(str, ...chars) {\n    if (chars.length === 0) {\n        return str.trim();\n    }\n    const pattern = \"[\" + escape(chars.join(\"\")) + \"]+\";\n    return str.replace(new RegExp(\"^\" + pattern), \"\").replace(new RegExp(pattern + \"$\"), \"\");\n}\nexport function trimStart(str, ...chars) {\n    return chars.length === 0\n        ? str.trimStart()\n        : str.replace(new RegExp(\"^[\" + escape(chars.join(\"\")) + \"]+\"), \"\");\n}\nexport function trimEnd(str, ...chars) {\n    return chars.length === 0\n        ? str.trimEnd()\n        : str.replace(new RegExp(\"[\" + escape(chars.join(\"\")) + \"]+$\"), \"\");\n}\nexport function filter(pred, x) {\n    return x.split(\"\").filter((c) => pred(c)).join(\"\");\n}\nexport function substring(str, startIndex, length) {\n    if ((startIndex + (length || 0) > str.length)) {\n        throw new Error(\"Invalid startIndex and/or length\");\n    }\n    return length != null ? str.substr(startIndex, length) : str.substr(startIndex);\n}\nexport function fmt(strs, ...args) {\n    return ({ strs, args });\n}\nexport function fmtWith(fmts) {\n    return (strs, ...args) => ({ strs, args, fmts });\n}\nexport function getFormat(s) {\n    return s.fmts\n        ? s.strs.reduce((acc, newPart, index) => acc + `{${String(index - 1) + s.fmts[index - 1]}}` + newPart)\n        : s.strs.reduce((acc, newPart, index) => acc + `{${index - 1}}` + newPart);\n}\n","import { combineHashCodes, compare, compareArrays, equalArrays, equals, sameConstructor, numberHash, structuralHash } from \"./Util.js\";\nexport function seqToString(self) {\n    let count = 0;\n    let str = \"[\";\n    for (const x of self) {\n        if (count === 0) {\n            str += toString(x);\n        }\n        else if (count === 100) {\n            str += \"; ...\";\n            break;\n        }\n        else {\n            str += \"; \" + toString(x);\n        }\n        count++;\n    }\n    return str + \"]\";\n}\nexport function toString(x, callStack = 0) {\n    if (x != null && typeof x === \"object\") {\n        if (typeof x.toString === \"function\") {\n            return x.toString();\n        }\n        else if (Symbol.iterator in x) {\n            return seqToString(x);\n        }\n        else { // TODO: Date?\n            const cons = Object.getPrototypeOf(x)?.constructor;\n            return cons === Object && callStack < 10\n                // Same format as recordToString\n                ? \"{ \" + Object.entries(x).map(([k, v]) => k + \" = \" + toString(v, callStack + 1)).join(\"\\n  \") + \" }\"\n                : cons?.name ?? \"\";\n        }\n    }\n    return String(x);\n}\nexport function unionToString(name, fields) {\n    if (fields.length === 0) {\n        return name;\n    }\n    else {\n        let fieldStr;\n        let withParens = true;\n        if (fields.length === 1) {\n            fieldStr = toString(fields[0]);\n            withParens = fieldStr.indexOf(\" \") >= 0;\n        }\n        else {\n            fieldStr = fields.map((x) => toString(x)).join(\", \");\n        }\n        return name + (withParens ? \" (\" : \" \") + fieldStr + (withParens ? \")\" : \"\");\n    }\n}\nexport class Union {\n    get name() {\n        return this.cases()[this.tag];\n    }\n    toJSON() {\n        return this.fields.length === 0 ? this.name : [this.name].concat(this.fields);\n    }\n    toString() {\n        return unionToString(this.name, this.fields);\n    }\n    GetHashCode() {\n        const hashes = this.fields.map((x) => structuralHash(x));\n        hashes.splice(0, 0, numberHash(this.tag));\n        return combineHashCodes(hashes);\n    }\n    Equals(other) {\n        if (this === other) {\n            return true;\n        }\n        else if (!sameConstructor(this, other)) {\n            return false;\n        }\n        else if (this.tag === other.tag) {\n            return equalArrays(this.fields, other.fields);\n        }\n        else {\n            return false;\n        }\n    }\n    CompareTo(other) {\n        if (this === other) {\n            return 0;\n        }\n        else if (!sameConstructor(this, other)) {\n            return -1;\n        }\n        else if (this.tag === other.tag) {\n            return compareArrays(this.fields, other.fields);\n        }\n        else {\n            return this.tag < other.tag ? -1 : 1;\n        }\n    }\n}\nfunction recordToJSON(self) {\n    const o = {};\n    const keys = Object.keys(self);\n    for (let i = 0; i < keys.length; i++) {\n        o[keys[i]] = self[keys[i]];\n    }\n    return o;\n}\nfunction recordToString(self) {\n    return \"{ \" + Object.entries(self).map(([k, v]) => k + \" = \" + toString(v)).join(\"\\n  \") + \" }\";\n}\nfunction recordGetHashCode(self) {\n    const hashes = Object.values(self).map((v) => structuralHash(v));\n    return combineHashCodes(hashes);\n}\nfunction recordEquals(self, other) {\n    if (self === other) {\n        return true;\n    }\n    else if (!sameConstructor(self, other)) {\n        return false;\n    }\n    else {\n        const thisNames = Object.keys(self);\n        for (let i = 0; i < thisNames.length; i++) {\n            if (!equals(self[thisNames[i]], other[thisNames[i]])) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\nfunction recordCompareTo(self, other) {\n    if (self === other) {\n        return 0;\n    }\n    else if (!sameConstructor(self, other)) {\n        return -1;\n    }\n    else {\n        const thisNames = Object.keys(self);\n        for (let i = 0; i < thisNames.length; i++) {\n            const result = compare(self[thisNames[i]], other[thisNames[i]]);\n            if (result !== 0) {\n                return result;\n            }\n        }\n        return 0;\n    }\n}\nexport class Record {\n    toJSON() { return recordToJSON(this); }\n    toString() { return recordToString(this); }\n    GetHashCode() { return recordGetHashCode(this); }\n    Equals(other) { return recordEquals(this, other); }\n    CompareTo(other) { return recordCompareTo(this, other); }\n}\nexport class FSharpRef {\n    get contents() {\n        return this.getter();\n    }\n    set contents(v) {\n        this.setter(v);\n    }\n    constructor(contentsOrGetter, setter) {\n        if (typeof setter === \"function\") {\n            this.getter = contentsOrGetter;\n            this.setter = setter;\n        }\n        else {\n            this.getter = () => contentsOrGetter;\n            this.setter = (v) => { contentsOrGetter = v; };\n        }\n    }\n}\n// EXCEPTIONS\n// Exception is intentionally not derived from Error, for performance reasons (see #2160)\nexport class Exception {\n    constructor(message) {\n        this.message = message;\n    }\n}\nexport function isException(x) {\n    return x instanceof Exception || x instanceof Error;\n}\nexport function isPromise(x) {\n    return x instanceof Promise;\n}\nexport function ensureErrorOrException(e) {\n    // Exceptionally admitting promises as errors for compatibility with React.suspense (see #3298)\n    return (isException(e) || isPromise(e)) ? e : new Error(String(e));\n}\nexport class FSharpException extends Exception {\n    toJSON() { return recordToJSON(this); }\n    toString() { return recordToString(this); }\n    GetHashCode() { return recordGetHashCode(this); }\n    Equals(other) { return recordEquals(this, other); }\n    CompareTo(other) { return recordCompareTo(this, other); }\n}\nexport class MatchFailureException extends FSharpException {\n    constructor(arg1, arg2, arg3) {\n        super();\n        this.arg1 = arg1;\n        this.arg2 = arg2 | 0;\n        this.arg3 = arg3 | 0;\n        this.message = \"The match cases were incomplete\";\n    }\n}\nexport class Attribute {\n}\n","// tslint:disable:ban-types\nexport function isArrayLike(x) {\n    return Array.isArray(x) || ArrayBuffer.isView(x);\n}\nexport function isIterable(x) {\n    return x != null && typeof x === \"object\" && Symbol.iterator in x;\n}\nexport function isEnumerable(x) {\n    return x != null && typeof x.GetEnumerator === \"function\";\n}\nexport function isComparer(x) {\n    return x != null && typeof x.Compare === \"function\";\n}\nexport function isComparable(x) {\n    return x != null && typeof x.CompareTo === \"function\";\n}\nexport function isEquatable(x) {\n    return x != null && typeof x.Equals === \"function\";\n}\nexport function isHashable(x) {\n    return x != null && typeof x.GetHashCode === \"function\";\n}\nexport function isDisposable(x) {\n    return x != null && typeof x.Dispose === \"function\";\n}\nexport function disposeSafe(x) {\n    if (isDisposable(x)) {\n        x.Dispose();\n    }\n}\nexport function defaultOf() {\n    return null;\n}\nexport function sameConstructor(x, y) {\n    return Object.getPrototypeOf(x)?.constructor === Object.getPrototypeOf(y)?.constructor;\n}\nexport class Enumerable {\n    constructor(en) {\n        this.en = en;\n    }\n    GetEnumerator() { return this.en; }\n    \"System.Collections.IEnumerable.GetEnumerator\"() { return this.en; }\n    [Symbol.iterator]() {\n        return this;\n    }\n    next() {\n        const hasNext = this.en[\"System.Collections.IEnumerator.MoveNext\"]();\n        const current = hasNext ? this.en[\"System.Collections.Generic.IEnumerator`1.get_Current\"]() : undefined;\n        return { done: !hasNext, value: current };\n    }\n}\nexport class Enumerator {\n    constructor(iter) {\n        this.iter = iter;\n        this.current = defaultOf();\n    }\n    [\"System.Collections.Generic.IEnumerator`1.get_Current\"]() {\n        return this.current;\n    }\n    [\"System.Collections.IEnumerator.get_Current\"]() {\n        return this.current;\n    }\n    [\"System.Collections.IEnumerator.MoveNext\"]() {\n        const cur = this.iter.next();\n        this.current = cur.value;\n        return !cur.done;\n    }\n    [\"System.Collections.IEnumerator.Reset\"]() {\n        throw new Error(\"JS iterators cannot be reset\");\n    }\n    Dispose() {\n        return;\n    }\n}\nexport function toEnumerable(e) {\n    if (isEnumerable(e)) {\n        return e;\n    }\n    else {\n        return new Enumerable(new Enumerator(e[Symbol.iterator]()));\n    }\n}\nexport function getEnumerator(e) {\n    if (isEnumerable(e)) {\n        return e.GetEnumerator();\n    }\n    else {\n        return new Enumerator(e[Symbol.iterator]());\n    }\n}\nexport function toIterator(en) {\n    return {\n        next() {\n            const hasNext = en[\"System.Collections.IEnumerator.MoveNext\"]();\n            const current = hasNext ? en[\"System.Collections.Generic.IEnumerator`1.get_Current\"]() : undefined;\n            return { done: !hasNext, value: current };\n        },\n    };\n}\nexport function enumerableToIterator(e) {\n    return toIterator(toEnumerable(e).GetEnumerator());\n}\nexport class Comparer {\n    constructor(f) {\n        this.Compare = f || compare;\n    }\n}\nexport function comparerFromEqualityComparer(comparer) {\n    // Sometimes IEqualityComparer also implements IComparer\n    if (isComparer(comparer)) {\n        return new Comparer(comparer.Compare);\n    }\n    else {\n        return new Comparer((x, y) => {\n            const xhash = comparer.GetHashCode(x);\n            const yhash = comparer.GetHashCode(y);\n            if (xhash === yhash) {\n                return comparer.Equals(x, y) ? 0 : -1;\n            }\n            else {\n                return xhash < yhash ? -1 : 1;\n            }\n        });\n    }\n}\nexport function assertEqual(actual, expected, msg) {\n    if (!equals(actual, expected)) {\n        throw Object.assign(new Error(msg || `Expected: ${expected} - Actual: ${actual}`), {\n            actual,\n            expected,\n        });\n    }\n}\nexport function assertNotEqual(actual, expected, msg) {\n    if (equals(actual, expected)) {\n        throw Object.assign(new Error(msg || `Expected: ${expected} - Actual: ${actual}`), {\n            actual,\n            expected,\n        });\n    }\n}\nexport class Lazy {\n    constructor(factory) {\n        this.factory = factory;\n        this.isValueCreated = false;\n    }\n    get Value() {\n        if (!this.isValueCreated) {\n            this.createdValue = this.factory();\n            this.isValueCreated = true;\n        }\n        return this.createdValue;\n    }\n    get IsValueCreated() {\n        return this.isValueCreated;\n    }\n}\nexport function lazyFromValue(v) {\n    return new Lazy(() => v);\n}\nexport function padWithZeros(i, length) {\n    let str = i.toString(10);\n    while (str.length < length) {\n        str = \"0\" + str;\n    }\n    return str;\n}\nexport function padLeftAndRightWithZeros(i, lengthLeft, lengthRight) {\n    let str = i.toString(10);\n    while (str.length < lengthLeft) {\n        str = \"0\" + str;\n    }\n    while (str.length < lengthRight) {\n        str = str + \"0\";\n    }\n    return str;\n}\nexport function dateOffset(date) {\n    const date1 = date;\n    return typeof date1.offset === \"number\"\n        ? date1.offset\n        : (date.kind === 1 /* DateKind.UTC */\n            ? 0 : date.getTimezoneOffset() * -60000);\n}\nexport function int16ToString(i, radix) {\n    i = i < 0 && radix != null && radix !== 10 ? 0xFFFF + i + 1 : i;\n    return i.toString(radix);\n}\nexport function int32ToString(i, radix) {\n    i = i < 0 && radix != null && radix !== 10 ? 0xFFFFFFFF + i + 1 : i;\n    return i.toString(radix);\n}\nexport function int64ToString(i, radix) {\n    i = i < 0 && radix != null && radix !== 10 ? 0xffffffffffffffffn + i + 1n : i;\n    return i.toString(radix);\n}\nexport class ObjectRef {\n    static id(o) {\n        if (!ObjectRef.idMap.has(o)) {\n            ObjectRef.idMap.set(o, ++ObjectRef.count);\n        }\n        return ObjectRef.idMap.get(o);\n    }\n}\nObjectRef.idMap = new WeakMap();\nObjectRef.count = 0;\nexport function stringHash(s) {\n    let i = 0;\n    let h = 5381;\n    const len = s.length;\n    while (i < len) {\n        h = (h * 33) ^ s.charCodeAt(i++);\n    }\n    return h;\n}\nexport function numberHash(x) {\n    return x * 2654435761 | 0;\n}\nexport function bigintHash(x) {\n    return stringHash(x.toString(32));\n}\n// From https://stackoverflow.com/a/37449594\nexport function combineHashCodes(hashes) {\n    let h1 = 0;\n    const len = hashes.length;\n    for (let i = 0; i < len; i++) {\n        const h2 = hashes[i];\n        h1 = ((h1 << 5) + h1) ^ h2;\n    }\n    return h1;\n}\nexport function physicalHash(x) {\n    if (x == null) {\n        return 0;\n    }\n    switch (typeof x) {\n        case \"boolean\":\n            return x ? 1 : 0;\n        case \"number\":\n            return numberHash(x);\n        case \"bigint\":\n            return bigintHash(x);\n        case \"string\":\n            return stringHash(x);\n        default:\n            return numberHash(ObjectRef.id(x));\n    }\n}\nexport function identityHash(x) {\n    if (isHashable(x)) {\n        return x.GetHashCode();\n    }\n    else {\n        return physicalHash(x);\n    }\n}\nexport function dateHash(x) {\n    return x.getTime();\n}\nexport function arrayHash(x) {\n    const len = x.length;\n    const hashes = new Array(len);\n    for (let i = 0; i < len; i++) {\n        hashes[i] = structuralHash(x[i]);\n    }\n    return combineHashCodes(hashes);\n}\nexport function structuralHash(x) {\n    if (x == null) {\n        return 0;\n    }\n    switch (typeof x) {\n        case \"boolean\":\n            return x ? 1 : 0;\n        case \"number\":\n            return numberHash(x);\n        case \"bigint\":\n            return bigintHash(x);\n        case \"string\":\n            return stringHash(x);\n        default: {\n            if (isHashable(x)) {\n                return x.GetHashCode();\n            }\n            else if (isArrayLike(x)) {\n                return arrayHash(x);\n            }\n            else if (x instanceof Date) {\n                return dateHash(x);\n            }\n            else if (Object.getPrototypeOf(x)?.constructor === Object) {\n                // TODO: check call-stack to prevent cyclic objects?\n                const hashes = Object.values(x).map((v) => structuralHash(v));\n                return combineHashCodes(hashes);\n            }\n            else {\n                // Classes don't implement GetHashCode by default, but must use identity hashing\n                return numberHash(ObjectRef.id(x));\n                // return stringHash(String(x));\n            }\n        }\n    }\n}\n// Intended for custom numeric types, like long or decimal\nexport function fastStructuralHash(x) {\n    return stringHash(String(x));\n}\n// Intended for declared types that may or may not implement GetHashCode\nexport function safeHash(x) {\n    // return x == null ? 0 : isHashable(x) ? x.GetHashCode() : numberHash(ObjectRef.id(x));\n    return identityHash(x);\n}\nexport function equalArraysWith(x, y, eq) {\n    if (x == null) {\n        return y == null;\n    }\n    if (y == null) {\n        return false;\n    }\n    if (x.length !== y.length) {\n        return false;\n    }\n    for (let i = 0; i < x.length; i++) {\n        if (!eq(x[i], y[i])) {\n            return false;\n        }\n    }\n    return true;\n}\nexport function equalArrays(x, y) {\n    return equalArraysWith(x, y, equals);\n}\nfunction equalObjects(x, y) {\n    const xKeys = Object.keys(x);\n    const yKeys = Object.keys(y);\n    if (xKeys.length !== yKeys.length) {\n        return false;\n    }\n    xKeys.sort();\n    yKeys.sort();\n    for (let i = 0; i < xKeys.length; i++) {\n        if (xKeys[i] !== yKeys[i] || !equals(x[xKeys[i]], y[yKeys[i]])) {\n            return false;\n        }\n    }\n    return true;\n}\nexport function physicalEquality(x, y) {\n    return x === y;\n}\nexport function equals(x, y) {\n    if (x === y) {\n        return true;\n    }\n    else if (x == null) {\n        return y == null;\n    }\n    else if (y == null) {\n        return false;\n    }\n    else if (isEquatable(x)) {\n        return x.Equals(y);\n    }\n    else if (isArrayLike(x)) {\n        return isArrayLike(y) && equalArrays(x, y);\n    }\n    else if (typeof x !== \"object\") {\n        return false;\n    }\n    else if (x instanceof Date) {\n        return (y instanceof Date) && compareDates(x, y) === 0;\n    }\n    else {\n        return Object.getPrototypeOf(x)?.constructor === Object && equalObjects(x, y);\n    }\n}\nexport function compareDates(x, y) {\n    let xtime;\n    let ytime;\n    // DateTimeOffset and DateTime deals with equality differently.\n    if (\"offset\" in x && \"offset\" in y) {\n        xtime = x.getTime();\n        ytime = y.getTime();\n    }\n    else {\n        xtime = x.getTime() + dateOffset(x);\n        ytime = y.getTime() + dateOffset(y);\n    }\n    return xtime === ytime ? 0 : (xtime < ytime ? -1 : 1);\n}\nexport function comparePrimitives(x, y) {\n    return x === y ? 0 : (x < y ? -1 : 1);\n}\nexport function compareArraysWith(x, y, comp) {\n    if (x == null) {\n        return y == null ? 0 : 1;\n    }\n    if (y == null) {\n        return -1;\n    }\n    if (x.length !== y.length) {\n        return x.length < y.length ? -1 : 1;\n    }\n    for (let i = 0, j = 0; i < x.length; i++) {\n        j = comp(x[i], y[i]);\n        if (j !== 0) {\n            return j;\n        }\n    }\n    return 0;\n}\nexport function compareArrays(x, y) {\n    return compareArraysWith(x, y, compare);\n}\nfunction compareObjects(x, y) {\n    const xKeys = Object.keys(x);\n    const yKeys = Object.keys(y);\n    if (xKeys.length !== yKeys.length) {\n        return xKeys.length < yKeys.length ? -1 : 1;\n    }\n    xKeys.sort();\n    yKeys.sort();\n    for (let i = 0, j = 0; i < xKeys.length; i++) {\n        const key = xKeys[i];\n        if (key !== yKeys[i]) {\n            return key < yKeys[i] ? -1 : 1;\n        }\n        else {\n            j = compare(x[key], y[key]);\n            if (j !== 0) {\n                return j;\n            }\n        }\n    }\n    return 0;\n}\nexport function compare(x, y) {\n    if (x === y) {\n        return 0;\n    }\n    else if (x == null) {\n        return y == null ? 0 : -1;\n    }\n    else if (y == null) {\n        return 1;\n    }\n    else if (isComparable(x)) {\n        return x.CompareTo(y);\n    }\n    else if (isArrayLike(x)) {\n        return isArrayLike(y) ? compareArrays(x, y) : -1;\n    }\n    else if (typeof x !== \"object\") {\n        return x < y ? -1 : 1;\n    }\n    else if (x instanceof Date) {\n        return y instanceof Date ? compareDates(x, y) : -1;\n    }\n    else {\n        return Object.getPrototypeOf(x)?.constructor === Object ? compareObjects(x, y) : -1;\n    }\n}\nexport function min(comparer, x, y) {\n    return comparer(x, y) < 0 ? x : y;\n}\nexport function max(comparer, x, y) {\n    return comparer(x, y) > 0 ? x : y;\n}\nexport function clamp(comparer, value, min, max) {\n    return (comparer(value, min) < 0) ? min : (comparer(value, max) > 0) ? max : value;\n}\nexport function createAtom(value) {\n    let atom = value;\n    return (...args) => {\n        if (args.length === 0) {\n            return atom;\n        }\n        else {\n            atom = args[0];\n        }\n    };\n}\nexport function createObj(fields) {\n    const obj = {};\n    for (const kv of fields) {\n        obj[kv[0]] = kv[1];\n    }\n    return obj;\n}\nexport function jsOptions(mutator) {\n    const opts = {};\n    mutator(opts);\n    return opts;\n}\nexport function round(value, digits = 0) {\n    const m = Math.pow(10, digits);\n    const n = +(digits ? value * m : value).toFixed(8);\n    const i = Math.floor(n);\n    const f = n - i;\n    const e = 1e-8;\n    const r = (f > 0.5 - e && f < 0.5 + e) ? ((i % 2 === 0) ? i : i + 1) : Math.round(n);\n    return digits ? r / m : r;\n}\nexport function sign(x) {\n    return x > 0 ? 1 : x < 0 ? -1 : 0;\n}\nexport function unescapeDataString(s) {\n    // https://stackoverflow.com/a/4458580/524236\n    return decodeURIComponent((s).replace(/\\+/g, \"%20\"));\n}\nexport function escapeDataString(s) {\n    return encodeURIComponent(s).replace(/!/g, \"%21\")\n        .replace(/'/g, \"%27\")\n        .replace(/\\(/g, \"%28\")\n        .replace(/\\)/g, \"%29\")\n        .replace(/\\*/g, \"%2A\");\n}\nexport function escapeUriString(s) {\n    return encodeURI(s);\n}\n// ICollection.Clear and Count members can be called on Arrays\n// or Dictionaries so we need a runtime check (see #1120)\nexport function count(col) {\n    if (isArrayLike(col)) {\n        return col.length;\n    }\n    else {\n        let count = 0;\n        for (const _ of col) {\n            count++;\n        }\n        return count;\n    }\n}\nexport function clear(col) {\n    if (isArrayLike(col)) {\n        col.splice(0);\n    }\n    else {\n        col.clear();\n    }\n}\nconst curried = new WeakMap();\nexport function uncurry2(f) {\n    if (f == null) {\n        return null;\n    }\n    const f2 = (a1, a2) => f(a1)(a2);\n    curried.set(f2, f);\n    return f2;\n}\nexport function curry2(f) {\n    return curried.get(f) ?? ((a1) => (a2) => f(a1, a2));\n}\nexport function uncurry3(f) {\n    if (f == null) {\n        return null;\n    }\n    const f2 = (a1, a2, a3) => f(a1)(a2)(a3);\n    curried.set(f2, f);\n    return f2;\n}\nexport function curry3(f) {\n    return curried.get(f)\n        ?? ((a1) => (a2) => (a3) => f(a1, a2, a3));\n}\nexport function uncurry4(f) {\n    if (f == null) {\n        return null;\n    }\n    const f2 = (a1, a2, a3, a4) => f(a1)(a2)(a3)(a4);\n    curried.set(f2, f);\n    return f2;\n}\nexport function curry4(f) {\n    return curried.get(f)\n        ?? ((a1) => (a2) => (a3) => (a4) => f(a1, a2, a3, a4));\n}\nexport function uncurry5(f) {\n    if (f == null) {\n        return null;\n    }\n    const f2 = (a1, a2, a3, a4, a5) => f(a1)(a2)(a3)(a4)(a5);\n    curried.set(f2, f);\n    return f2;\n}\nexport function curry5(f) {\n    return curried.get(f)\n        ?? ((a1) => (a2) => (a3) => (a4) => (a5) => f(a1, a2, a3, a4, a5));\n}\nexport function uncurry6(f) {\n    if (f == null) {\n        return null;\n    }\n    const f2 = (a1, a2, a3, a4, a5, a6) => f(a1)(a2)(a3)(a4)(a5)(a6);\n    curried.set(f2, f);\n    return f2;\n}\nexport function curry6(f) {\n    return curried.get(f)\n        ?? ((a1) => (a2) => (a3) => (a4) => (a5) => (a6) => f(a1, a2, a3, a4, a5, a6));\n}\nexport function uncurry7(f) {\n    if (f == null) {\n        return null;\n    }\n    const f2 = (a1, a2, a3, a4, a5, a6, a7) => f(a1)(a2)(a3)(a4)(a5)(a6)(a7);\n    curried.set(f2, f);\n    return f2;\n}\nexport function curry7(f) {\n    return curried.get(f)\n        ?? ((a1) => (a2) => (a3) => (a4) => (a5) => (a6) => (a7) => f(a1, a2, a3, a4, a5, a6, a7));\n}\nexport function uncurry8(f) {\n    if (f == null) {\n        return null;\n    }\n    const f2 = (a1, a2, a3, a4, a5, a6, a7, a8) => f(a1)(a2)(a3)(a4)(a5)(a6)(a7)(a8);\n    curried.set(f2, f);\n    return f2;\n}\nexport function curry8(f) {\n    return curried.get(f)\n        ?? ((a1) => (a2) => (a3) => (a4) => (a5) => (a6) => (a7) => (a8) => f(a1, a2, a3, a4, a5, a6, a7, a8));\n}\nexport function uncurry9(f) {\n    if (f == null) {\n        return null;\n    }\n    const f2 = (a1, a2, a3, a4, a5, a6, a7, a8, a9) => f(a1)(a2)(a3)(a4)(a5)(a6)(a7)(a8)(a9);\n    curried.set(f2, f);\n    return f2;\n}\nexport function curry9(f) {\n    return curried.get(f)\n        ?? ((a1) => (a2) => (a3) => (a4) => (a5) => (a6) => (a7) => (a8) => (a9) => f(a1, a2, a3, a4, a5, a6, a7, a8, a9));\n}\nexport function uncurry10(f) {\n    if (f == null) {\n        return null;\n    }\n    const f2 = (a1, a2, a3, a4, a5, a6, a7, a8, a9, a10) => f(a1)(a2)(a3)(a4)(a5)(a6)(a7)(a8)(a9)(a10);\n    curried.set(f2, f);\n    return f2;\n}\nexport function curry10(f) {\n    return curried.get(f)\n        ?? ((a1) => (a2) => (a3) => (a4) => (a5) => (a6) => (a7) => (a8) => (a9) => (a10) => f(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10));\n}\nexport function uncurry11(f) {\n    if (f == null) {\n        return null;\n    }\n    const f2 = (a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11) => f(a1)(a2)(a3)(a4)(a5)(a6)(a7)(a8)(a9)(a10)(a11);\n    curried.set(f2, f);\n    return f2;\n}\nexport function curry11(f) {\n    return curried.get(f)\n        ?? ((a1) => (a2) => (a3) => (a4) => (a5) => (a6) => (a7) => (a8) => (a9) => (a10) => (a11) => f(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11));\n}\nexport function uncurry12(f) {\n    if (f == null) {\n        return null;\n    }\n    const f2 = (a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12) => f(a1)(a2)(a3)(a4)(a5)(a6)(a7)(a8)(a9)(a10)(a11)(a12);\n    curried.set(f2, f);\n    return f2;\n}\nexport function curry12(f) {\n    return curried.get(f)\n        ?? ((a1) => (a2) => (a3) => (a4) => (a5) => (a6) => (a7) => (a8) => (a9) => (a10) => (a11) => (a12) => f(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12));\n}\nexport function uncurry13(f) {\n    if (f == null) {\n        return null;\n    }\n    const f2 = (a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13) => f(a1)(a2)(a3)(a4)(a5)(a6)(a7)(a8)(a9)(a10)(a11)(a12)(a13);\n    curried.set(f2, f);\n    return f2;\n}\nexport function curry13(f) {\n    return curried.get(f)\n        ?? ((a1) => (a2) => (a3) => (a4) => (a5) => (a6) => (a7) => (a8) => (a9) => (a10) => (a11) => (a12) => (a13) => f(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13));\n}\nexport function uncurry14(f) {\n    if (f == null) {\n        return null;\n    }\n    const f2 = (a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14) => f(a1)(a2)(a3)(a4)(a5)(a6)(a7)(a8)(a9)(a10)(a11)(a12)(a13)(a14);\n    curried.set(f2, f);\n    return f2;\n}\nexport function curry14(f) {\n    return curried.get(f)\n        ?? ((a1) => (a2) => (a3) => (a4) => (a5) => (a6) => (a7) => (a8) => (a9) => (a10) => (a11) => (a12) => (a13) => (a14) => f(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14));\n}\nexport function uncurry15(f) {\n    if (f == null) {\n        return null;\n    }\n    const f2 = (a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15) => f(a1)(a2)(a3)(a4)(a5)(a6)(a7)(a8)(a9)(a10)(a11)(a12)(a13)(a14)(a15);\n    curried.set(f2, f);\n    return f2;\n}\nexport function curry15(f) {\n    return curried.get(f)\n        ?? ((a1) => (a2) => (a3) => (a4) => (a5) => (a6) => (a7) => (a8) => (a9) => (a10) => (a11) => (a12) => (a13) => (a14) => (a15) => f(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15));\n}\nexport function uncurry16(f) {\n    if (f == null) {\n        return null;\n    }\n    const f2 = (a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16) => f(a1)(a2)(a3)(a4)(a5)(a6)(a7)(a8)(a9)(a10)(a11)(a12)(a13)(a14)(a15)(a16);\n    curried.set(f2, f);\n    return f2;\n}\nexport function curry16(f) {\n    return curried.get(f)\n        ?? ((a1) => (a2) => (a3) => (a4) => (a5) => (a6) => (a7) => (a8) => (a9) => (a10) => (a11) => (a12) => (a13) => (a14) => (a15) => (a16) => f(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16));\n}\nexport function uncurry17(f) {\n    if (f == null) {\n        return null;\n    }\n    const f2 = (a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17) => f(a1)(a2)(a3)(a4)(a5)(a6)(a7)(a8)(a9)(a10)(a11)(a12)(a13)(a14)(a15)(a16)(a17);\n    curried.set(f2, f);\n    return f2;\n}\nexport function curry17(f) {\n    return curried.get(f)\n        ?? ((a1) => (a2) => (a3) => (a4) => (a5) => (a6) => (a7) => (a8) => (a9) => (a10) => (a11) => (a12) => (a13) => (a14) => (a15) => (a16) => (a17) => f(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17));\n}\nexport function uncurry18(f) {\n    if (f == null) {\n        return null;\n    }\n    const f2 = (a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18) => f(a1)(a2)(a3)(a4)(a5)(a6)(a7)(a8)(a9)(a10)(a11)(a12)(a13)(a14)(a15)(a16)(a17)(a18);\n    curried.set(f2, f);\n    return f2;\n}\nexport function curry18(f) {\n    return curried.get(f)\n        ?? ((a1) => (a2) => (a3) => (a4) => (a5) => (a6) => (a7) => (a8) => (a9) => (a10) => (a11) => (a12) => (a13) => (a14) => (a15) => (a16) => (a17) => (a18) => f(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18));\n}\nexport function uncurry19(f) {\n    if (f == null) {\n        return null;\n    }\n    const f2 = (a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19) => f(a1)(a2)(a3)(a4)(a5)(a6)(a7)(a8)(a9)(a10)(a11)(a12)(a13)(a14)(a15)(a16)(a17)(a18)(a19);\n    curried.set(f2, f);\n    return f2;\n}\nexport function curry19(f) {\n    return curried.get(f)\n        ?? ((a1) => (a2) => (a3) => (a4) => (a5) => (a6) => (a7) => (a8) => (a9) => (a10) => (a11) => (a12) => (a13) => (a14) => (a15) => (a16) => (a17) => (a18) => (a19) => f(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19));\n}\nexport function uncurry20(f) {\n    if (f == null) {\n        return null;\n    }\n    const f2 = (a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20) => f(a1)(a2)(a3)(a4)(a5)(a6)(a7)(a8)(a9)(a10)(a11)(a12)(a13)(a14)(a15)(a16)(a17)(a18)(a19)(a20);\n    curried.set(f2, f);\n    return f2;\n}\nexport function curry20(f) {\n    return curried.get(f)\n        ?? ((a1) => (a2) => (a3) => (a4) => (a5) => (a6) => (a7) => (a8) => (a9) => (a10) => (a11) => (a12) => (a13) => (a14) => (a15) => (a16) => (a17) => (a18) => (a19) => (a20) => f(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20));\n}\n// More performant method to copy arrays, see #2352\nexport function copyToArray(source, sourceIndex, target, targetIndex, count) {\n    if (ArrayBuffer.isView(source) && ArrayBuffer.isView(target)) {\n        target.set(source.subarray(sourceIndex, sourceIndex + count), targetIndex);\n    }\n    else {\n        for (let i = 0; i < count; ++i) {\n            target[targetIndex + i] = source[sourceIndex + i];\n        }\n    }\n}\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n// expose the modules object (__webpack_modules__)\n__webpack_require__.m = __webpack_modules__;\n\n","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = function(module) {\n\tvar getter = module && module.__esModule ?\n\t\tfunction() { return module['default']; } :\n\t\tfunction() { return module; };\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = function(exports, definition) {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }","// define __esModule on exports\n__webpack_require__.r = function(exports) {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","var scriptUrl;\nif (__webpack_require__.g.importScripts) scriptUrl = __webpack_require__.g.location + \"\";\nvar document = __webpack_require__.g.document;\nif (!scriptUrl && document) {\n\tif (document.currentScript)\n\t\tscriptUrl = document.currentScript.src;\n\tif (!scriptUrl) {\n\t\tvar scripts = document.getElementsByTagName(\"script\");\n\t\tif(scripts.length) scriptUrl = scripts[scripts.length - 1].src\n\t}\n}\n// When supporting browsers where an automatic publicPath is not supported you must specify an output.publicPath manually via configuration\n// or pass an empty string (\"\") and set the __webpack_public_path__ variable from your code to use your own logic.\nif (!scriptUrl) throw new Error(\"Automatic publicPath is not supported in this browser\");\nscriptUrl = scriptUrl.replace(/#.*$/, \"\").replace(/\\?.*$/, \"\").replace(/\\/[^\\/]+$/, \"/\");\n__webpack_require__.p = scriptUrl;","__webpack_require__.b = document.baseURI || self.location.href;\n\n// object to store loaded and loading chunks\n// undefined = chunk not loaded, null = chunk preloaded/prefetched\n// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded\nvar installedChunks = {\n\t41: 0\n};\n\n// no chunk on demand loading\n\n// no prefetching\n\n// no preloaded\n\n// no HMR\n\n// no HMR manifest\n\n// no on chunks loaded\n\n// no jsonp function","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\n__webpack_require__(14183);\nvar __webpack_exports__ = __webpack_require__(93823);\n"],"names":["Common_fs_js_1","require","Option_js_1","Random_fs_js_1","Backtrack_fs_js_1","SIDES","toPaddlers","rawInput","paddlers","_i","rawInput_1","length","row","side","paddler","Paddler","Number","push","toTable","boat","result","i","a","left","b","right","newRow","getName","opt","unwrap","Name","exports","input","input_1","name_1","arrangeRandom","searchBacktrack","backend_1","TABLE_NAME","prepare","Excel","run","context","__awaiter","_this","range","workbook","getSelectedRange","topThree","getAbsoluteResizedRange","load","sync","_a","sent","sheet","worksheet","table","tables","getItemOrNullObject","isNullObject","expensesTable","add","address","name","getHeaderRowRange","values","rows","Office","requirements","isSetSupported","getUsedRange","format","autofitColumns","autofitRows","activate","console","error","concat","error_1","arrange","worksheets","getActiveWorksheet","getDataBodyRange","output","backtrack","header","target","getRangeByIndexes","rowIndex","columnIndex","columnCount","getExtendedRange","KeyboardDirection","down","clear","lefts","rowCount","rights","formattedBoat","__spreadArray","slice","numberFormat","error_2","onReady","info","host","HostType","document","getElementById","style","display","onclick","___HTML_LOADER_IMPORT_0___","URL","___HTML_LOADER_IMPORT_1___","module","url","options","String","__esModule","default","hash","maybeNeedQuotes","test","TypeInfo","constructor","fullname","generics","construct","parent","fields","cases","enumCases","this","toString","fullName","GetHashCode","getHashCode","Equals","other","equals","getGenerics","t","fullnameHash","genHashes","map","t1","t2","getRecordElements","k1","v1","k2","v2","record_type","undefined","option_type","generic","array_type","string_type","int32_type","float64_type","elemType","getElementType","x","join","Error","canBeLeft","canBeRight","Weight","Side","super","Paddler_$reflection","underlyingType","Boat","size","this$","maxNameLen","Compare","formatPaddler","paddler_1","horizonalLine","matchValue","arg_3","arg_5","Boat_$reflection","Boat_Make","makeOneSide","Array","from","some","_arg","cost","getWeight","array","GetZero","Add","y","leftWeight","rightWeight","howManyOnWrongSide","boatSide","isCompatible","arg","p_1","x_1","Math","abs","rangeDouble","start","step","stop","zero","stepFn","stepComparedWithZero","stepGreaterThanZero","comparedWithLast","makeRangeStepFunction","integralRangeStep","initialSizeLeft","haveMoreToTraverse","l","r","mover","backup","maxInLeft","h","t_1","h_1","number","t_2","h_2","t_3","h_3","Native_randomNext","min","max","floor","random","NonSeeded","Next0","Next1","maxValue","Next2","minValue","NextDouble","NextBytes","buffer","rhi","j","Native_randomBytes","testExpr","rand","tempArray","n","k","temp","value","leftSize","size_3","searchRandom","attempts","fill","targetIndex","count","singleton","cons","ar","len","copy","equalsWith","array1","array2","length1","length2","sumBy","projection","adder","acc","FSharpList","head","tail","xs_1_mut","ys_1_mut","loop","xs_1","ys_1","matchValue_1","xt","yt","i_mut","h_mut","toJSON","CompareTo","c","GetEnumerator","ListEnumerator$1","Symbol","iterator","xs","it","current","_","Dispose","FSharpList_get_Empty","FSharpList_Cons_305B8EAC","FSharpList__get_IsEmpty","FSharpList__get_Tail","empty","isEmpty","FSharpList__get_Length","FSharpList__get_Head","reverse","folder","state","fold","ofArray","tail_1","res","ofArrayWithTail","ofSeq","xs_3","root","node","enumerator","xs_5","Some","ofNullable","toNullable","flatten","toArray","defaultArg","defaultValue","defaultArgWith","defThunk","orElse","ifNone","orElseWith","ifNoneThunk","filter","predicate","mapping","map2","opt1","opt2","map3","opt3","bind","binder","tryOp","op","SR_enumerationAlreadyFinished","SR_enumerationNotStarted","SR_inputSequenceEmpty","SR_notEnoughElements","Enumerator_notStarted","Enumerator_alreadyFinished","Enumerator_Seq","f","str","e","Enumerator_FromFunctions$1","next","dispose","Enumerator_noReset","Enumerator_FromFunctions$1_$ctor_58C54629","Enumerator_generateWhileSome","openf","compute","closef","curr","started","finish","s","mkSeq","Enumerator_Seq_$ctor_673A07F2","argName","Operators_NullArg","delay","generator","sources","outerOpt","innerOpt","finished","inner","outer","copyOfStruct","outerOpt_1","innerOpt_1","inner_1","outer_1","Enumerator_concat","unfold","st_1","Enumerator_unfold","toList","generate","create","append","ys","choose","chooser","e_1","enumerateWhile","guard","initialize","initializeInfinite","CachedSeq$1","cleanup","getEnumerator","toIterator","reduce","acc_mut","take","zip","tupledArg","e1","e2","tupledArg_1","collect","comparer","minBy","dateOffsetToString","offset","isMinus","hours","minutes","dateToHalfUTCString","date","half","toISOString","substring","indexOf","dateToStringWithCustomFormat","utc","replace","match","rep","NaN","getUTCFullYear","getFullYear","getUTCMonth","getMonth","getUTCDate","getDate","getUTCHours","getHours","getUTCMinutes","getMinutes","getUTCSeconds","getSeconds","getUTCMilliseconds","getMilliseconds","isNaN","symbol","sd","toPrecision","dp","toExponential","BigInt","asUintN","toHex","fsFormatRegExp","printf","cont","lastIndex","strParts","matches","strIdx","exec","matchIndex","index","createPrinter","toText","continuePrint","formatReplacement","flags","padLength","precision","sign","toLowerCase","isLessThan","multiply","parseInt","toFixed","toUpperCase","Date","_provider","d","getTime","dateWithOffset","dateToISOStringWithOffset","dateToStringWithOffset","kind","toUTCString","toLocaleString","toLocaleDateString","toLocaleTimeString","printOffset","getTimezoneOffset","dateToISOString","dateToStringWithKind","zeroFlag","minusFlag","ch","pad","_strParts","_matches","_result","padArg","args","_padLength","splice","delimiter","isArray","isRight","replicate","callStack","self","seqToString","Object","getPrototypeOf","entries","v","Record","o","keys","recordToJSON","recordToString","hashes","recordGetHashCode","thisNames","recordEquals","recordCompareTo","isArrayLike","ArrayBuffer","isView","disposeSafe","isDisposable","defaultOf","sameConstructor","Enumerable","en","hasNext","done","Enumerator","iter","cur","padWithZeros","dateOffset","date1","ObjectRef","static","idMap","has","set","get","stringHash","charCodeAt","numberHash","combineHashCodes","h1","structuralHash","bigintHash","isHashable","arrayHash","dateHash","id","equalArraysWith","eq","isEquatable","equalArrays","compareDates","xKeys","yKeys","sort","equalObjects","xtime","ytime","comparePrimitives","compare","isComparable","comp","compareArraysWith","compareArrays","key","compareObjects","WeakMap","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","__webpack_modules__","call","m","getter","definition","defineProperty","enumerable","g","globalThis","Function","window","obj","prop","prototype","hasOwnProperty","toStringTag","scriptUrl","importScripts","location","currentScript","src","scripts","getElementsByTagName","p","baseURI","href"],"sourceRoot":""}